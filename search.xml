<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Mysql基础知识</title>
      <link href="/2022/04/13/Mysql%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2022/04/13/Mysql%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<pre><code>     - **mysql关键字不区分大小写**     - 创建数据库     </code></pre><pre class="line-numbers language-none"><code class="language-none">create database [if not exists] westos;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>     - 删除数据库</code></pre><pre class="line-numbers language-none"><code class="language-none">drop database [if exists] westos;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>     - 使用数据库</code></pre><pre class="line-numbers language-none"><code class="language-none">use &#96;school&#96;-- 如果你的表名或者字段名是一个特殊字符（关键字），就需要带&#96;&#96;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><a name="bAxBQ"></a></p><h1 id="数据库的列类型"><a href="#数据库的列类型" class="headerlink" title="数据库的列类型"></a>数据库的列类型</h1><p><a name="ZvL3k"></a></p><h2 id="1-数值"><a href="#1-数值" class="headerlink" title="1.数值"></a>1.数值</h2><pre><code>        - **整数**           1. tinyint  1个字节           1. smallint 2个字节           1. mediumint 3个字节           1. **int 4个字节**           1. bigint 8个字节        - 小数           1. float 4个字节           1. double 8个字节           1. decimal 字符串形式的浮点数</code></pre><p><a name="p7DiI"></a></p><h2 id="2-字符串"><a href="#2-字符串" class="headerlink" title="2.字符串"></a>2.字符串</h2><pre><code>        1. char 字符串固定大小的0-255        1. **varchar 可变字符串 0-65535常用的 String**        1. tinytext 微型文本 2^8-1        1. text 文本串 2^16-1</code></pre><p><a name="rCRjW"></a></p><h2 id="3-时间日期"><a href="#3-时间日期" class="headerlink" title="3.时间日期"></a>3.时间日期</h2><pre><code>        1. date YYYY-MM-DD 日期        1. time HH:mm：ss 时间格式        1. **datetime YYYY-MM-DD HH:mm：ss 最常用**        1. timestamp 时间戳 1970 1.1 到现在的毫秒数        1. year 年份表示</code></pre><p><a name="Jb3Dd"></a></p><h2 id="4-null"><a href="#4-null" class="headerlink" title="4.null"></a>4.null</h2><pre><code>        1. 没有值，未知         1. ==不要使用NULL进行运算</code></pre><p><a name="SVqqK"></a></p><h1 id="数据库的字段属性（重点）"><a href="#数据库的字段属性（重点）" class="headerlink" title="数据库的字段属性（重点）"></a>数据库的字段属性（重点）</h1><pre><code>     - unsigned ： 该列不能声明为负数     - zerofill：零填充      - 自增： 自动在上一条记录的基础上+1（默认）通常用来设计唯一的主键~index，必须是整数类型。     - 非空 ：Not null     - default ： 设置默认的值</code></pre><pre class="line-numbers language-none"><code class="language-none">&#x2F;* 每一个表，都必须存在以下五个字段！未来做项目用的，表示一个记录存在意义！id主键&#96;version&#96;乐观锁is_delete伪删除gmt_create创建时间gmt_update修改时间*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a name="z1lSm"></a></p><h1 id="创建数据库表"><a href="#创建数据库表" class="headerlink" title="创建数据库表"></a>创建数据库表</h1><pre class="line-numbers language-none"><code class="language-none">CREATE TABLE IF NOT EXISTS &#96;student&#96; (&#96;id&#96; INT(4) NOT NULL AUTO_INCREMENT COMMENT &#39;学号&#39;,&#96;name&#96; VARCHAR(30) NOT NULL DEFAULT &#39;匿名&#39; COMMENT &#39;姓名&#39;,&#96;pwd&#96; VARCHAR(20) NOT NULL DEFAULT &#39;123456&#39; COMMENT &#39;密码&#39;,&#96;sex&#96; VARCHAR(2) NOT NULL DEFAULT &#39;女&#39; COMMENT &#39;性别&#39;,&#96;birthday&#96; DATETIME DEFAULT NULL COMMENT &#39;出生日期&#39;,&#96;address&#96; VARCHAR(100) DEFAULT NULL COMMENT &#39;家庭住址&#39;,&#96;email&#96; VARCHAR(50) DEFAULT NULL COMMENT &#39;邮箱&#39;,PRIMARY KEY(&#96;id&#96;))ENGINE&#x3D;INNODB DEFAULT CHARSET&#x3D;utf8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a name="MwNAO"></a></p><h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><pre class="line-numbers language-none"><code class="language-none">CREATE TABLE [IF NOT EXISTS] &#96;表名&#96;(&#96;字段名&#96; 列属性 [属性] [索引] [注释]，    &#96;字段名&#96; 列属性 [属性] [索引] [注释]，    ......    &#96;字段名&#96; 列属性 [属性] [索引] [注释])[表类型][字符集设置][注释]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a name="Bk7eN"></a></p><h1 id="关于数据库引擎"><a href="#关于数据库引擎" class="headerlink" title="关于数据库引擎"></a>关于数据库引擎</h1><ul><li>Innodb：默认使用</li><li>MYISAM ：早些年使用</li></ul><p>区别：</p><table><thead><tr><th><br /></th><th>MYISAM</th><th>INNODB</th></tr></thead><tbody><tr><td>事务支持</td><td>不支持</td><td>支持</td></tr><tr><td>数据行锁定</td><td>不支持</td><td>支持</td></tr><tr><td>外键约束</td><td>不支持</td><td>支持</td></tr><tr><td>全文索引</td><td>支持</td><td>不支持</td></tr><tr><td>表空间的大小</td><td>较少</td><td>较大，约为MYISAM的2倍</td></tr></tbody></table><p>常规使用操作：<br />MYISAM: 节约空间，速度较快<br />Innodb：安全性高，事物的处理，多表多用户操作</p><p><a name="emxyx"></a></p><h1 id="修改删除表"><a href="#修改删除表" class="headerlink" title="修改删除表"></a>修改删除表</h1><p><a name="TKXo0"></a></p><h2 id="修改："><a href="#修改：" class="headerlink" title="修改："></a>修改：</h2><pre class="line-numbers language-none"><code class="language-none">-- 修改表名ALTER TABLE 旧表名 RENAME AS 新表名ALTER TABLE student RENAME AS student1-- 增加表的字段 ALTER TABLE 表名 ADD 字段名 字段的列属性ALTER TABLE student1 ADD age INT(3)-- 修改表的字段 （重命名，修改约束！）-- ALTER TABLE 表名 MODIFY 字段名 列属性[]ALTER TABLE student1 MODIFY age VARCHAR(3)   -- 修改约束-- ALTER TABLE 表名 MODIFY 旧字段名 新字段名 列属性[]ALTER TABLE student1 CHANGE age Age INT(3)   -- 字段重命名-- 删除表的字段ALTER TABLE 表名 DROP 字段名ALTER TABLE student1 DROP Age<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a name="WoGI6"></a></p><h2 id="删除："><a href="#删除：" class="headerlink" title="删除："></a>删除：</h2><pre class="line-numbers language-none"><code class="language-none">-- 删除表（如果表存在再删除）DROP TABLE IF EXISTS teacher<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><a name="NvsTd"></a></p><h1 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h1><pre class="line-numbers language-none"><code class="language-none">CREATE TABLE IF NOT EXISTS &#96;grade&#96; (&#96;gradeid&#96; INT(10) NOT NULL AUTO_INCREMENT COMMENT &#39;年级id&#39;,&#96;gradename&#96; VARCHAR(50) NOT NULL COMMENT &#39;年级名称&#39;,PRIMARY KEY(&#96;gradeid&#96;))ENGINE&#x3D;INNODB DEFAULT CHARSET&#x3D;utf8CREATE TABLE IF NOT EXISTS &#96;student&#96; (&#96;id&#96; INT(4) NOT NULL AUTO_INCREMENT COMMENT &#39;学号&#39;,&#96;name&#96; VARCHAR(30) NOT NULL DEFAULT &#39;匿名&#39; COMMENT &#39;姓名&#39;,&#96;pwd&#96; VARCHAR(20) NOT NULL DEFAULT &#39;123456&#39; COMMENT &#39;密码&#39;,&#96;sex&#96; VARCHAR(2) NOT NULL DEFAULT &#39;女&#39; COMMENT &#39;性别&#39;,&#96;birthday&#96; DATETIME DEFAULT NULL COMMENT &#39;出生日期&#39;,&#96;gradeid&#96; INT(10) NOT NULL COMMENT &#39;学生的年级&#39;,&#96;address&#96; VARCHAR(100) DEFAULT NULL COMMENT &#39;家庭住址&#39;,&#96;email&#96; VARCHAR(50) DEFAULT NULL COMMENT &#39;邮箱&#39;,PRIMARY KEY(&#96;id&#96;))ENGINE&#x3D;INNODB DEFAULT CHARSET&#x3D;utf8ALTER TABLE &#96;student&#96;ADD CONSTRAINT &#96;FK_gradeid&#96; FOREIGN KEY (&#96;gradeid&#96;) REFERENCES &#96;grade&#96; (&#96;gradeid&#96;)-- ALTER TABLE 表名 ADD CONSTRAINT 约束名 FOREIGN KEY（作为外键的列）REFERENCES 哪个表（哪个字段）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上的操作都是物理外键，数据库级别的外键，不建议使用！（避免数据库过多造成困扰）<br /><strong>最佳实践</strong></p><ul><li><p>数据库就是单纯的表，只用来存数据，只有行（数据）和列（字段）</p></li><li><p>我们想使用多张表的数据，想使用外键（程序去实现）<br><a name="VR11g"></a></p><h1 id="sql操作"><a href="#sql操作" class="headerlink" title="sql操作"></a>sql操作</h1><p><a name="BZw8Q"></a></p><h2 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h2><p>语法：<code>insert into 表名([字段1,字段2,字段3]) values(&#39;值1&#39;),(&#39;值2&#39;),(&#39;值3&#39;,...)</code></p><pre class="line-numbers language-none"><code class="language-none">-- 插入语句（添加）-- insert into 表名([字段1,字段2,字段3]) values(&#39;值1&#39;),(&#39;值2&#39;),(&#39;值3&#39;,...)INSERT INTO &#96;grade&#96;(&#96;gradename&#96;) VALUES (&#39;大四&#39;)-- 由于主键自增我们可以省略 （如果不写表的字段，他就会一一匹配）INSERT INTO &#96;grade&#96; VALUES (&#39;大三&#39;)-- 一般写插入语句，我们一定要数据和字段一一对应！-- 插入多个字段INSERT INTO &#96;grade&#96;(&#96;gradename&#96;) VALUES (&#39;大三&#39;),(&#39;大二&#39;),(&#39;大一&#39;)INSERT INTO &#96;student&#96;(&#96;name&#96;) VALUES (&#39;张三&#39;)INSERT INTO &#96;student&#96;(&#96;name&#96;,&#96;pwd&#96;,&#96;sex&#96;) VALUES (&#39;张三&#39;,&#39;aaaaaa&#39;,&#39;男&#39;)INSERT INTO &#96;student&#96;(&#96;name&#96;,&#96;pwd&#96;,&#96;sex&#96;) VALUES (&#39;李四&#39;,&#39;aaaaaa&#39;,&#39;男&#39;),(&#39;王五&#39;,&#39;aaaaaa&#39;,&#39;男&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：</p><pre><code>1. 字段和字段之间使用英文逗号隔开1. 字段是可以省略的，但是后面的值必须要一一对应，不能少1. 可以同时插入多条数据，VALUES后面的值，需要使用，隔开即可VALUSE (),(),...</code></pre></li></ul><p><a name="LYeek"></a></p><h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><p>语法：UPDATE 表名 SET colnum_name&#x3D;value，[colnum_name&#x3D;value,…] WHERE [条件]</p><p><a name="gFZum"></a></p><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>语法：delete from 表名 [where 条件]&#96;<br />Truncate命令：完全清空一个数据库表，表的结构和索引约束不会变！<br><a name="nHAac"></a></p><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p>语法：SELECT 字段,… FROM 表</p><p><strong>distinct</strong><br />作用：去除SELECT查询出来的结果中重复的数据，重复的数据只显示一条</p><p><a name="DZMxb"></a></p><h3 id="联表查询"><a href="#联表查询" class="headerlink" title="联表查询"></a>联表查询</h3><p>Join<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/26758626/1648484644146-dff18579-65cd-4869-b455-affe56c8fdf8.png#clientId=u2d08d468-e396-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u7f5eaaa9&originHeight=752&originWidth=1000&originalType=url&ratio=1&rotation=0&showTitle=false&size=401494&status=done&style=none&taskId=u2d5d341d-c9e6-4b3b-92d3-9557c795809&title=" alt="image.png"><br />   </p><table><thead><tr><th>操作符名称</th><th>描述</th></tr></thead><tbody><tr><td>INNER JOIN</td><td>如果表中至少有一个匹配，则返回行</td></tr><tr><td>LEFT JOIN</td><td>即使右表中没有匹配，也从左表中返回所有的行</td></tr><tr><td>RIGHT JOIN</td><td>即使左表中没有匹配，也从右表中返回所有的行</td></tr></tbody></table><p><strong>自连接</strong><br />自己的表和自己的表连接，核心：<strong>一张表拆为两张一样的表即可</strong><br><a name="gJmwK"></a></p><h2 id="分页和排序"><a href="#分页和排序" class="headerlink" title="分页和排序"></a>分页和排序</h2><p><a name="L8XZn"></a></p><h3 id="排序："><a href="#排序：" class="headerlink" title="排序："></a>排序：</h3><pre><code>     - 关键字：order by     - 升序 : asc     - 降序 ：desc</code></pre><p><a name="hqWZD"></a></p><h3 id="分页："><a href="#分页：" class="headerlink" title="分页："></a>分页：</h3><pre><code>     - 语法：limit 起始页 页面的大小</code></pre><p><a name="Dj0Iv"></a></p><h2 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h2><table><thead><tr><th>函数名称</th><th>描述</th></tr></thead><tbody><tr><td>COUNT()</td><td>计数</td></tr><tr><td>SUM()</td><td>求和</td></tr><tr><td>AVG()</td><td>平均值</td></tr><tr><td>MAX()</td><td>最大值</td></tr><tr><td>MIN()</td><td>最小值</td></tr></tbody></table><p>注意：</p><ul><li>从含义上讲，count(1) 与 count(*) 都表示对全部数据行的查询。<ul><li>count(字段) 会统计该字段在表中出现的次数，忽略字段为null 的情况。即不统计字段为null 的记录。</li><li>count(*) 包括了所有的列，相当于行数，在统计结果的时候，包含字段为null 的记录；</li><li>count(1) 用1代表代码行，在统计结果的时候，包含字段为null 的记录 。<br><a name="FJmoq"></a><h2 id="分组和过滤"><a href="#分组和过滤" class="headerlink" title="分组和过滤"></a>分组和过滤</h2><pre class="line-numbers language-none"><code class="language-none">-- 查询不同课程的平均分,最高分,最低分-- 前提:根据不同的课程进行分组SELECT subjectname,AVG(studentresult) AS 平均分,MAX(StudentResult) AS 最高分,MIN(StudentResult) AS 最低分FROM result AS rINNER JOIN &#96;subject&#96; AS sON r.subjectno &#x3D; s.subjectnoGROUP BY r.subjectno --通过什么字段来分组HAVING 平均分&gt;80;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul><p><strong>分组之后，只能用having过滤</strong></p><p><a name="XkaND"></a></p><h1 id="数据库级别的MD5"><a href="#数据库级别的MD5" class="headerlink" title="数据库级别的MD5"></a>数据库级别的MD5</h1><ul><li>主要增强算法复杂度和不可逆性</li><li>MD5<strong>不可逆</strong>，具体的值的MD5是一样的</li><li>MD5破解网站的原理，背后有一个字典，MD5加密后的值，加密的前值<br><a name="ZVnEq"></a><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1>定义：将一组sql放在一个批次中去执行<br><a name="mfaZW"></a><h2 id="事务-ACID原则"><a href="#事务-ACID原则" class="headerlink" title="事务 ACID原则"></a>事务 ACID原则</h2><pre><code>      - 原子性（Atomicity）</code></pre></li></ul><p><strong>不可分割，要么都成功，要么都失败</strong></p><pre><code>        - 一致性（Consistency）</code></pre><p><strong>事务前后的数据的完整性保持一致</strong></p><pre><code>        - 隔离性（Isolation）</code></pre><p><strong>事务的隔离型性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离</strong></p><pre><code>        - 持久性（Durabilty）</code></pre><p><strong>事务一旦提交则不可逆，被持久化到数据库中</strong><br><a name="OddDZ"></a></p><h2 id="引发的问题"><a href="#引发的问题" class="headerlink" title="引发的问题"></a>引发的问题</h2><p><a name="Z5w5Z"></a></p><h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p>一个事务读取了另一个事物未提交的数据<br><a name="tKYK4"></a></p><h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p>在一个事务内读取表中某一行的数据，多次读取的结果不同<br><a name="GbnC2"></a></p><h3 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h3><p>在一个事务内读取到了另一个事务插入的数据，导致前后读取的数据总量不一致。  <br />MySQL是默认开启事务提交的</p><pre class="line-numbers language-none"><code class="language-none">-- 事务-- mysql是默认开启事务自动提交的SET autocommit &#x3D; 0 -- 关闭SET autocommit &#x3D; 1 -- 开启（默认的）-- 手动处理事务SET autocommit &#x3D; 0 -- 关闭自动提交-- 事务开启START TRANSACTION -- 标记一个事务的开始，从这个之后的sql都在同一个事务内-- 提交 ： 持久化 （成功！）COMMIT-- 回滚： 回到原来的样子 （失败！）ROLLBACK-- 事务结束SET autocommit &#x3D; 1 -- 开启自动提交SAVEPOINT 保存点名 -- 设置一个事务的保存点ROLLBACK TO SAVEPOINT 保存点名 -- 回滚到保存点RELEASE SAVEPOINT 保存点名 -- 撤销保存点<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a name="SG1wt"></a></p><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>本质：是一种数据结构，帮助高效获取数据。<br><a name="y2z0u"></a></p><h2 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h2><ul><li>主键索引（primary key）</li></ul><p>唯一标识，主键不可重复，只能有一个列作为主键</p><ul><li>唯一索引（Unique key）</li></ul><p>可重复，避免重复的列出现，多个列都可以标识为唯一索引</p><ul><li>常规索引（key&#x2F;index）</li></ul><p>默认，index&#x2F;key 来设置</p><ul><li>全文索引（FullText）</li></ul><p>在特定的数据库引擎下才有，如：MyISAM<br />快速定位数据<br><a name="xUGbf"></a></p><h2 id="索隐原则："><a href="#索隐原则：" class="headerlink" title="索隐原则："></a>索隐原则：</h2><ul><li>不是越多越好</li><li>不要对进程变动数据加索引</li><li>小数据量的表不需要加索引</li><li>索引一般加在常用来查询的字段上<br><a name="IAacW"></a><h2 id="数据结构：B-TREE（Innodb的默认数据结构）"><a href="#数据结构：B-TREE（Innodb的默认数据结构）" class="headerlink" title="数据结构：B TREE（Innodb的默认数据结构）"></a>数据结构：B TREE（Innodb的默认数据结构）</h2></li></ul><p><a name="IQDeT"></a></p><h1 id="数据库三大范式"><a href="#数据库三大范式" class="headerlink" title="数据库三大范式"></a>数据库三大范式</h1><p><strong>为什么需要数据规范化？</strong></p><ul><li>信息重复</li><li>更新异常</li><li>插入异常<ul><li>无法正常显示信息</li></ul></li><li>删除异常<ul><li>丢失有效的信息</li></ul></li></ul><p><strong>三大范式</strong><br><a name="ittiW"></a></p><h2 id="第一范式-1st-NF"><a href="#第一范式-1st-NF" class="headerlink" title="第一范式 (1st NF)"></a>第一范式 (1st NF)</h2><p>要求数据库表的每一列都是不可分割的原子数据项。<br><a name="eyS6M"></a></p><h2 id="第二范式-2nd-NF"><a href="#第二范式-2nd-NF" class="headerlink" title="第二范式(2nd NF)"></a>第二范式(2nd NF)</h2><p>满足第二范式（2NF）必须先满足第一范式（1NF）。<br />第二范式要求每个表只描述一件事情<br /><strong>在第一范式的基础上，非主属性必须完全依赖于候选码（消除非主属性对于主码的部分函数依赖）</strong><br />确保每一列都和主键相关，而不能只与主键的某一部分相关<br><a name="gm1UK"></a></p><h2 id="第三范式-3rd-NF"><a href="#第三范式-3rd-NF" class="headerlink" title="第三范式(3rd NF)"></a>第三范式(3rd NF)</h2><p>满足第三范式（3NF）必须先满足第二范式（2NF）。<br /><strong>第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。</strong><br /><strong>任何非主属性不依赖于其他非主属性</strong><br /><strong>消除了传递依赖</strong></p><p>三个范式是规范了数据库的设计<br /><strong>规范性 和 性能的问题</strong><br />关联查询的表不得超过三张表</p><ul><li>考虑商业化的需求和目标，（成本，用户体验！）数据库的性能更加重要</li><li>在规范性能的问题的时候，需要适当的考虑一下 规范性！</li><li>故意给某些表增加一些冗余的字段。（从多表查询中变为单表查询）</li><li>故意增加一些计算列（从大数据量降低为小数据量的查询：索引）</li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM</title>
      <link href="/2022/04/13/JVM/"/>
      <url>/2022/04/13/JVM/</url>
      
        <content type="html"><![CDATA[<ul><li>请你谈谈对JVM的理解? java8虚拟机和之前的变化更新</li><li>什么是OOM(内存溢出)? 什么是栈溢出(stackOverFlowError)? 怎么分析?</li><li>JVM常用的调优参数有哪些?</li><li>内存快照如何抓取? 怎么分析Domp文件 ? 知道吗?</li><li>谈谈JVM中,类加载器你的认识?</li></ul><h1 id="1-JVM的位置"><a href="#1-JVM的位置" class="headerlink" title="1.JVM的位置"></a>1.JVM的位置</h1><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26758626/1648544772214-88c91aeb-5084-40ed-9c39-0c263f359e4a.png#clientId=ua2864186-cdc8-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u0bda4197&originHeight=526&originWidth=524&originalType=url&ratio=1&rotation=0&showTitle=false&size=119986&status=done&style=none&taskId=ue48ccd1e-4dab-4c86-af41-84396fa35fe&title=" alt="image.png"></p><h1 id="2-jvm的体系"><a href="#2-jvm的体系" class="headerlink" title="2.jvm的体系"></a>2.jvm的体系</h1><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26758626/1648544892759-f947e880-ceb1-42db-b98e-8d5295b63562.png#clientId=ua2864186-cdc8-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u9136ed99&originHeight=586&originWidth=863&originalType=url&ratio=1&rotation=0&showTitle=false&size=141205&status=done&style=none&taskId=u395bb536-6df4-4fe2-b7f3-161c9f30130&title=" alt="image.png"><br /><img src="https://cdn.nlark.com/yuque/0/2022/png/26758626/1648545189519-c0d39c94-e78b-4ff1-99c8-023090c5a5b2.png#clientId=ua2864186-cdc8-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u4f6323d3&originHeight=525&originWidth=738&originalType=url&ratio=1&rotation=0&showTitle=false&size=117675&status=done&style=none&taskId=uc2c6e7e2-5ec3-427d-b07d-8180845e934&title=" alt="image.png"></p><h1 id="3-类加载器"><a href="#3-类加载器" class="headerlink" title="3.类加载器"></a>3.类加载器</h1><pre><code> 作用：加载 class文件</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26758626/1648545610429-11508ee3-4ac1-4533-8b86-4bb382797f39.png#clientId=ua2864186-cdc8-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uaabadb7f&originHeight=438&originWidth=741&originalType=url&ratio=1&rotation=0&showTitle=false&size=66883&status=done&style=none&taskId=u09a651ba-7a78-4883-9734-b2dbb1fcb67&title=" alt="image.png"><br />种类：</p><ul><li>虚拟机自带的加载器</li><li>启动类（根）加载器</li><li>扩展类加载器</li><li>应用程序加载器</li></ul><h1 id="4-双亲委派机制"><a href="#4-双亲委派机制" class="headerlink" title="4.双亲委派机制"></a>4.双亲委派机制</h1><p>app—&gt;扩展类(ext) —-&gt; (启动类)根加载器(rt)<br />当一个类收到了类加载请求，他首先不会尝试自己去加载这个类，而是把这个请求委派给父类去完成，每一个层次类加载器都是如此， 因此所有的加载请求都应该传送到启动类加载其中<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/26758626/1648547288200-e817c805-1153-4ccc-8b71-4fa78816f63d.png#clientId=ua2864186-cdc8-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u02054e79&originHeight=1240&originWidth=1312&originalType=url&ratio=1&rotation=0&showTitle=false&size=473279&status=done&style=none&taskId=u51bcbf5d-9d34-4b25-bb23-55565a4351b&title=" alt="image.png"><br /><strong>过程：</strong>当一个类加载请求开始时，首先从APPClassLoader进入，先判断是否已经加载过，若加载过则不再加载，若没加载过，则交给自己的上层扩展类加载器，然后相同步骤，若没加载过，再交给启动类加载器，若启动类加载器也没加载过，此时已经没有再上一层的加载器了，于是判断自己是否可以加载，如果不能加载，则下沉到下一层的扩展类加载器，以此类推，直到应用程序类加载器，如果最后都不能加载，则报出ClassNotFoundException错误</p><h2 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h2><ul><li>避免重复加载类</li><li>沙箱安全机制</li></ul><h1 id="5-沙箱安全机制"><a href="#5-沙箱安全机制" class="headerlink" title="5.沙箱安全机制"></a>5.沙箱安全机制</h1><p>保证核心<a href="https://so.csdn.net/so/search?q=API&spm=1001.2101.3001.7020">API</a>源代码的保护，引导类加载器只加载核心API，不加载自定义的与核心API同名或同包名的API。</p><h1 id="6-Native"><a href="#6-Native" class="headerlink" title="6.Native"></a>6.Native</h1><p>Native 关键字 调用 本地方法栈—-&gt; JNI (java Native Interface本地方法接口) 调用外部语言程序<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/26758626/1648719749093-fc63d693-66f6-4ddd-a0b6-c2d93d12db46.png#clientId=uc724b46b-187a-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u27af7b57&originHeight=170&originWidth=692&originalType=url&ratio=1&rotation=0&showTitle=false&size=163877&status=done&style=none&taskId=uc6b8be60-239f-48d9-a808-7bc33c406c2&title=" alt="image.png"></p><h1 id="7-程序计数器"><a href="#7-程序计数器" class="headerlink" title="7.程序计数器"></a>7.程序计数器</h1><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26758626/1648720191895-f42faef2-9093-4945-a6ab-01bd7fbc603b.png#clientId=uc724b46b-187a-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u8db8404b&originHeight=128&originWidth=838&originalType=url&ratio=1&rotation=0&showTitle=false&size=101469&status=done&style=none&taskId=u58c5c243-f703-4e50-852d-7ee764e785a&title=" alt="image.png"></p><h1 id="8-方法区"><a href="#8-方法区" class="headerlink" title="8.方法区"></a>8.方法区</h1><p>方法区是被所有线程共享的,所有字段和方法字节码,以及一些特殊方法,如构造函数,接口代码也在此定义,简单说,所有定义的方法的信息都保存在该区域,<strong>此区域属于共享区间</strong>;<br />静态变量(static),常量(final),类信息(构造方法,接口定义),运行时的常量池存在方法区中,但是实例变量存在堆内存中,和方法区无关.<br />static ,final, Class , 常量池</p><h1 id="9-栈"><a href="#9-栈" class="headerlink" title="9.栈"></a>9.栈</h1><p>栈:栈<a href="https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98&spm=1001.2101.3001.7020">内存</a>,主管程序的运行,生命周期和线程同步;<br />线程结束,栈内存也就释放了,对于栈来说,不存在垃圾回收问题<br />一旦线程结束,栈就Over<br /><strong>主要存储</strong>：8大基本类型+ 对象引用+实例的方法</p><h1 id="10-堆"><a href="#10-堆" class="headerlink" title="10.堆"></a>10.堆</h1><p>一个JVM只有一个堆内存，堆内存的大小是可以调节的<br />堆内存中还要细分为三个区域:</p><ul><li>新生区 (伊甸园区) Young&#x2F;New ,eden space</li><li>养老区 old</li><li>永久区 Permanent jdk8之后叫做 “元空间”</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26758626/1648733899530-02206d74-10b0-41e6-b782-a205317234a9.png#clientId=uc724b46b-187a-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ud0377ec7&originHeight=574&originWidth=811&originalType=url&ratio=1&rotation=0&showTitle=false&size=137333&status=done&style=none&taskId=uef230b42-b2c5-4a52-bbf8-cd5cb9d236a&title=" alt="image.png"></p><h2 id="新生区（满了-轻GC）"><a href="#新生区（满了-轻GC）" class="headerlink" title="新生区（满了 轻GC）"></a>新生区（满了 轻GC）</h2><ul><li><p>类 ： 诞生和成长的地方 ， 甚至死亡；</p></li><li><p>伊甸园， 所有的对象都是在伊甸园区new出来的</p></li><li><p>幸存区（0，1）</p></li><li><p>经研究99%的对象都是临时对象</p><h2 id="老年区（满了-重GC）"><a href="#老年区（满了-重GC）" class="headerlink" title="老年区（满了 重GC）"></a>老年区（满了 重GC）</h2><h2 id="永久区（元空间）"><a href="#永久区（元空间）" class="headerlink" title="永久区（元空间）"></a>永久区（元空间）</h2><p>这个区域常驻内存的. 用来存放jdk自身携带的Class对象.Interface元数据,存储的是java运行时的一些环境或类信息,这个区域不存在垃圾回收!关闭vm虚拟就会释放这个区域的内存~.</p></li><li><p>jdk1.6之前 :永久代,常量池是在方法区;</p></li><li><p>jdk1.7 :永久代,但是慢慢退化了, 去永久代,常量池在堆中;</p></li><li><p>jdk1.8之后:无永久代, 常量池在元空间;</p></li><li><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26758626/1648735076894-6d8dd9c3-d949-4563-acad-7532a5ccc557.png#clientId=uc724b46b-187a-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u76447e61&originHeight=186&originWidth=670&originalType=url&ratio=1&rotation=0&showTitle=false&size=43913&status=done&style=none&taskId=ubb4b290d-d691-4bf5-9b65-c324405fb4c&title=" alt="image.png"></p></li></ul><p>元空间逻辑上存在，物理上不存在</p><h1 id="11-GC-垃圾回收"><a href="#11-GC-垃圾回收" class="headerlink" title="11.GC 垃圾回收"></a>11.GC 垃圾回收</h1><p>GC:作用区域 堆+方法区<br />JVM在进行GC时，并不是对这三个区域统一回收。大部分时候，回收都是新生代~</p><ul><li>新生代</li><li>幸存区（from ， to）</li><li>老年区</li></ul><p>GC两种：轻GC（普通GC），重GC（全局GC）</p><h1 id="12-常用算法"><a href="#12-常用算法" class="headerlink" title="12.常用算法"></a>12.常用算法</h1><h2 id="1-复制算法"><a href="#1-复制算法" class="headerlink" title="1.复制算法"></a>1.复制算法</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26758626/1648800715617-4d2b2864-bc17-4c29-873e-7d7a176bba81.png#clientId=uef992677-9ebd-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u94fd49aa&originHeight=620&originWidth=773&originalType=url&ratio=1&rotation=0&showTitle=false&size=201085&status=done&style=none&taskId=ub9dc2040-a063-4557-b771-e971b908039&title=" alt="image.png"></p><ul><li><p>好处:没有内存的碎片</p></li><li><p>坏处:浪费了内存空间:多了一半空间永远是空 to.假设对象100%存活(极端情况)</p></li><li><p><strong>复制算法最佳使用场景</strong>:对象存活度较低的时候:新生区;</p><h2 id="2-标记清除法"><a href="#2-标记清除法" class="headerlink" title="2.标记清除法"></a>2.标记清除法</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26758626/1648800795077-d75a4b16-4501-4c95-b525-842c971743d0.png#clientId=uef992677-9ebd-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uc89d7bb4&originHeight=513&originWidth=775&originalType=url&ratio=1&rotation=0&showTitle=false&size=120928&status=done&style=none&taskId=u8bd7aacb-8633-4feb-ab4d-d603c5fca19&title=" alt="image.png"></p></li><li><p>优点:不需要额外的空间</p></li><li><p>缺点:两次扫描,严重浪费时间,会产生内存碎片</p><h2 id="3-标记整理法"><a href="#3-标记整理法" class="headerlink" title="3.标记整理法"></a>3.标记整理法</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26758626/1648801445534-4625394c-fec6-4e6c-b97d-2c5680584317.png#clientId=uef992677-9ebd-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u741eb630&originHeight=568&originWidth=531&originalType=url&ratio=1&rotation=0&showTitle=false&size=116947&status=done&style=none&taskId=u00658d2e-c9f3-4909-95b1-f855cae4a3a&title=" alt="image.png"></p><h2 id="4-算法比较"><a href="#4-算法比较" class="headerlink" title="4.算法比较"></a>4.算法比较</h2></li></ul><p><strong>效率</strong>:复制算法&gt;标记清除算法&gt;标记压缩算法(时间复杂度)<br /><strong>内存整齐度</strong>:复制算法&#x3D;标记压缩算法&gt;标记清除算法<br /><strong>内存利用率</strong>:标记压缩算法&#x3D;标记清除算法&gt;复制算法</p>]]></content>
      
      
      <categories>
          
          <category> Java虚拟机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/04/13/hello-world/"/>
      <url>/2022/04/13/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> First Blog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
