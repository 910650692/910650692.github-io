<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>牛客论坛项目 实现模块(上)</title>
      <link href="/2022/04/20/%E7%89%9B%E5%AE%A2%E8%AE%BA%E5%9D%9B%E9%A1%B9%E7%9B%AE%20%E5%AE%9E%E7%8E%B0%E6%A8%A1%E5%9D%97%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
      <url>/2022/04/20/%E7%89%9B%E5%AE%A2%E8%AE%BA%E5%9D%9B%E9%A1%B9%E7%9B%AE%20%E5%AE%9E%E7%8E%B0%E6%A8%A1%E5%9D%97%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="1-登录"><a href="#1-登录" class="headerlink" title="1.登录"></a>1.登录</h2><h4 id="业务层"><a href="#业务层" class="headerlink" title="业务层"></a>业务层</h4><ol><li>前端传入账号和密码，进入数据库查询user</li><li>需要用一个Login ticket类来记录登录的凭证状态</li><li>先进行空值处理</li><li>再依次验证账号、密码、激活状态</li><li>验证密码过程，也需要加密判断<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 验证密码&#x2F;&#x2F;salt是创建账户时的一个随机字符串       password &#x3D; CommunityUtil.md5(password + user.getSalt());       if (!user.getPassword().equals(password)) &#123;           map.put(&quot;passwordMsg&quot;, &quot;密码不正确!&quot;);           return map;       &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><ul><li>然后生成登录凭证<h4 id="表现层"><a href="#表现层" class="headerlink" title="表现层"></a>表现层</h4></li></ul><ol><li>先检验验证码</li><li>检验账号密码，调用业务层接口</li><li>将登陆凭证放入Cookie<pre class="line-numbers language-none"><code class="language-none">if (map.containsKey(&quot;ticket&quot;)) &#123;           Cookie cookie &#x3D; new Cookie(&quot;ticket&quot;, map.get(&quot;ticket&quot;).toString());           cookie.setPath(contextPath);           cookie.setMaxAge(expiredSeconds);           response.addCookie(cookie);           return &quot;redirect:&#x2F;index&quot;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>html里取request的值，可以用${param.username}</li></ol><h2 id="2-显示登录信息"><a href="#2-显示登录信息" class="headerlink" title="2.显示登录信息"></a>2.显示登录信息</h2><ul><li>拦截器示例<ul><li>定义拦截器，实现HandlerInterceptor</li><li>配置拦截器，为它指定拦截、排除的路径</li></ul></li><li>拦截器应用<ul><li>在请求开始时查询登录用户</li><li>在本次请求中持有用户数据</li><li>在模板视图上显示用户数据</li><li>在请求结束时清理用户数据</li></ul></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26758626/1649174722405-2749389a-09d9-4f9a-8e52-681c48e4c284.png##clientId=u55419258-15d6-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=583&id=u17790cd4&margin=%5Bobject%20Object%5D&name=image.png&originHeight=583&originWidth=1180&originalType=binary&ratio=1&rotation=0&showTitle=false&size=59346&status=done&style=none&taskId=u2e58647d-9b65-4602-b11a-c0a1ef8b5a3&title=&width=1180" alt="image.png"></p><p>由于访问是并发访问，所以要把查到的user信息 存在threadlocal里，我们创建一个HostHolder工具类，代替session对象</p><h2 id="3-账号设置"><a href="#3-账号设置" class="headerlink" title="3.账号设置"></a>3.账号设置</h2><ul><li><p>上传文件</p><ul><li>请求：必须是POST请求</li><li>表单：enctype&#x3D;“multipart&#x2F;form-data”</li><li>Spring MVC：通过 MultipartFile 处理上传文件</li></ul></li><li><p>开发步骤</p><ul><li>访问账号设置页面</li><li>上传头像</li><li>获取头像<h2 id="4-检查登录状态"><a href="#4-检查登录状态" class="headerlink" title="4.检查登录状态"></a>4.检查登录状态</h2></li></ul></li><li><p>使用拦截器</p><ul><li>在方法前标注自定义注解</li><li>拦截所有请求，只处理带有该注解的方法</li></ul></li><li><p>自定义注解</p><ul><li>常用的元注解： @Target、@Retention、@Document、@Inherited</li></ul></li><li><p>如何读取注解： Method.getDeclaredAnnotations () Method.getAnnotation (Class annotationClass)</p><h2 id="5-过滤敏感词"><a href="#5-过滤敏感词" class="headerlink" title="5.过滤敏感词"></a>5.过滤敏感词</h2></li><li><p>前缀树</p><ul><li>名称：Trie、字典树、查找树</li><li>特点：查找效率高，消耗内存大</li><li>应用：字符串检索、词频统计、字符串排序等</li></ul></li><li><p>敏感词过滤器</p><ul><li>定义前缀树</li><li>根据敏感词，初始化前缀树</li><li>编写过滤敏感词的方法<h2 id="6-发帖功能"><a href="#6-发帖功能" class="headerlink" title="6.发帖功能"></a>6.发帖功能</h2></li></ul></li><li><p>AJAX</p><ul><li>Asynchronous JavaScript and XML</li><li>异步的JavaScript与XML，不是一门新技术，只是一个新的术语。</li><li>使用AJAX，网页能够将增量更新呈现在页面上，而不需要刷新整个页面。</li><li>虽然X代表XML，但目前JSON的使用比XML更加普遍。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/AJAX">https://developer.mozilla.org/zh-CN/docs/Web/Guide/AJAX</a></li></ul></li><li><p>示例</p><ul><li>使用jQuery发送AJAX请求。</li></ul></li><li><p>实践</p><ul><li>采用AJAX请求，实现发布帖子的功能。<h2 id="7-Spring事务管理"><a href="#7-Spring事务管理" class="headerlink" title="7.Spring事务管理"></a>7.Spring事务管理</h2></li></ul></li><li><p>声明式事务</p><ul><li>通过XML配置，声明某方法的事务特征。</li><li>通过注解，声明某方法的事务特征。</li></ul></li><li><p>编程式事务</p><ul><li>通过 TransactionTemplate 管理事务，并通过它执行数据库的操作。</li></ul></li></ul><p><strong>在项目中的应用：评论帖子</strong></p><h2 id="8-显示评论"><a href="#8-显示评论" class="headerlink" title="8.显示评论"></a>8.显示评论</h2><ul><li><p>数据层</p><ul><li>根据实体查询一页评论数据。</li><li>根据实体查询评论的数量。</li></ul></li><li><p>业务层</p><ul><li>处理查询评论的业务。</li><li>处理查询评论数量的业务。</li></ul></li><li><p>表现层</p><ul><li>显示帖子详情数据时，同时显示该帖子所有的评论数据。<h2 id="9-添加评论"><a href="#9-添加评论" class="headerlink" title="9.添加评论"></a>9.添加评论</h2></li></ul></li><li><p>数据层</p><ul><li>增加评论数据。</li><li>修改帖子的评论数量。</li></ul></li><li><p>业务层</p><ul><li>处理添加评论的业务：先增加评论、再更新帖子的评论数量。</li></ul></li><li><p>表现层</p><ul><li>处理添加评论数据的请求。</li><li>设置添加评论的表单。<h2 id="10-私信列表"><a href="#10-私信列表" class="headerlink" title="10.私信列表"></a>10.私信列表</h2></li></ul></li><li><p>私信列表</p><ul><li>查询当前用户的会话列表，每个会话只显示一条最新的私信。</li><li>支持分页显示。</li></ul></li><li><p>私信详情</p><ul><li>查询某个会话所包含的私信。</li><li>支持分页显示。<h2 id="11-发送私信"><a href="#11-发送私信" class="headerlink" title="11.发送私信"></a>11.发送私信</h2></li></ul></li><li><p>发送私信</p><ul><li>采用异步的方式发送私信。</li><li>发送成功后刷新私信列表。</li></ul></li><li><p>设置已读</p><ul><li>访问私信详情时，将显示的私信设置为已读状态。<h2 id="12-统一异常处理"><a href="#12-统一异常处理" class="headerlink" title="12.统一异常处理"></a>12.统一异常处理</h2></li></ul></li><li><p>@ControllerAdvice</p><ul><li>用于修饰类，表示该类是Controller的全局配置类。</li><li>在此类中，可以对Controller进行如下三种全局配置：异常处理方案、绑定数据方案、绑定参数方案。</li></ul></li><li><p>@ExceptionHandler</p><ul><li>用于修饰方法，该方法会在Controller出现异常后被调用，用于处理捕获到的异常。</li></ul></li><li><p>@ModelAttribute</p><ul><li>用于修饰方法，该方法会在Controller方法执行前被调用，用于为Model对象绑定参数。</li></ul></li><li><p>@DataBinder</p><ul><li>用于修饰方法，该方法会在Controller方法执行前被调用，用于绑定参数的转换器。<h2 id="13-同意记录日志"><a href="#13-同意记录日志" class="headerlink" title="13.同意记录日志"></a>13.同意记录日志</h2></li></ul></li></ul><p><strong>需求</strong>：</p><ul><li>帖子模块</li><li>评论模块</li><li>消息模块</li></ul><p><strong>AOP的概念</strong>：</p><ul><li>Aspect Oriented Programing，即面向方面（切面）编程。</li><li>AOP是一种编程思想，是对OOP的补充，可以进一步提高编程的效率。</li></ul><p><strong>AOP的实现</strong></p><ul><li>AspectJ<ul><li>AspectJ是语言级的实现，它扩展了Java语言，定义了AOP语法。</li><li>AspectJ在编译期织入代码，它有一个专门的编译器，用来生成遵守Java字节码规范的class文件。</li></ul></li><li>Spring AOP<ul><li>Spring AOP使用纯Java实现，它不需要专门的编译过程，也不需要特殊的类装载器。</li><li>Spring AOP在运行时通过代理的方式织入代码，只支持方法类型的连接点。</li><li>Spring支持对AspectJ的集成。</li></ul></li></ul><p><strong>Spring AOP</strong></p><ul><li><p>JDK动态代理</p><ul><li>Java提供的动态代理技术，可以在运行时创建接口的代理实例。</li><li>Spring AOP默认采用此种方式，在接口的代理实例中织入代码。</li></ul></li><li><p>CGLib动态代理</p><ul><li>采用底层的字节码技术，在运行时创建子类代理实例。</li><li>当目标对象不存在接口时，Spring AOP会采用此种方式，在子类实例中织入代码。<h2 id="14-Spring整合redis"><a href="#14-Spring整合redis" class="headerlink" title="14. Spring整合redis"></a>14. Spring整合redis</h2></li></ul></li><li><p>引入依赖</p><ul><li>spring-boot-starter-data-redis</li></ul></li><li><p>配置Redis</p><ul><li>配置数据库参数</li><li>编写配置类，构造RedisTemplate</li></ul></li><li><p>访问Redis</p><ul><li>redisTemplate.opsForValue()</li><li>redisTemplate.opsForHash()</li><li>redisTemplate.opsForList()</li><li>redisTemplate.opsForSet()</li><li>redisTemplate.opsForZSet()<h2 id="15-Redis实现点赞功能"><a href="#15-Redis实现点赞功能" class="headerlink" title="15. Redis实现点赞功能"></a>15. Redis实现点赞功能</h2></li></ul></li><li><p>点赞</p><ul><li>支持对帖子、评论点赞。</li><li>第1次点赞，第2次取消点赞。</li></ul></li><li><p>首页点赞数量</p><ul><li>统计帖子的点赞数量。</li></ul></li><li><p>详情页点赞数量</p><ul><li>统计点赞数量。</li><li>显示点赞状态。</li></ul></li></ul><p>点赞更新频率较高且需要实时更新，存在MySQL里会被高频读写，IO开销大，读内存速度快</p><p>先写个工具类，返回拼接过后的rediskey<br><img src="https://cdn.nlark.com/yuque/0/2022/png/26758626/1650378409011-31f430f2-62a3-4dc2-b279-fe160edc67f5.png##clientId=u1f8e6e56-996c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=258&id=ua8ae14fd&margin=%5Bobject%20Object%5D&name=image.png&originHeight=258&originWidth=741&originalType=binary&ratio=1&rotation=0&showTitle=false&size=33074&status=done&style=none&taskId=ud54a58ae-93e2-4f81-bded-67275db5d33&title=&width=741" alt="image.png"><br>直接在业务层进行开发</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">com<span class="token punctuation">.</span>nowcoder<span class="token punctuation">.</span>community<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">RedisKeyUtil</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Autowired</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>data<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>core<span class="token punctuation">.</span></span><span class="token class-name">RedisTemplate</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>stereotype<span class="token punctuation">.</span></span><span class="token class-name">Service</span><span class="token punctuation">;</span><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LikeService</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> <span class="token class-name">RedisTemplate</span> redisTemplate<span class="token punctuation">;</span>    <span class="token comment">//点赞</span>    <span class="token keyword">public</span>  <span class="token keyword">void</span> <span class="token function">like</span><span class="token punctuation">(</span><span class="token keyword">int</span> userId<span class="token punctuation">,</span> <span class="token keyword">int</span> entityType<span class="token punctuation">,</span> <span class="token keyword">int</span> entityId<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">String</span> entityLikeKey <span class="token operator">=</span> <span class="token class-name">RedisKeyUtil</span><span class="token punctuation">.</span><span class="token function">getEntityLikeKey</span><span class="token punctuation">(</span>entityType<span class="token punctuation">,</span>entityId<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span> isMember <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isMember</span><span class="token punctuation">(</span>entityLikeKey<span class="token punctuation">,</span>userId<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//先判断该用户是否点过赞</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>isMember<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            redisTemplate<span class="token punctuation">.</span><span class="token function">opsForSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>entityLikeKey<span class="token punctuation">,</span>userId<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>            redisTemplate<span class="token punctuation">.</span><span class="token function">opsForSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>entityLikeKey<span class="token punctuation">,</span>userId<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编写查看点赞数量以及个人点赞状态</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//查询某实体点赞的数量</span>  <span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">findEntityLikeCount</span><span class="token punctuation">(</span><span class="token keyword">int</span> entityType<span class="token punctuation">,</span> <span class="token keyword">int</span> entityId<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token class-name">String</span> entityLikeKey <span class="token operator">=</span> <span class="token class-name">RedisKeyUtil</span><span class="token punctuation">.</span><span class="token function">getEntityLikeKey</span><span class="token punctuation">(</span>entityType<span class="token punctuation">,</span>entityId<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span>entityLikeKey<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">//查询某人对某实体的点赞状态</span>  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findEntityLikeStatus</span><span class="token punctuation">(</span><span class="token keyword">int</span> userId<span class="token punctuation">,</span><span class="token keyword">int</span> entityType<span class="token punctuation">,</span> <span class="token keyword">int</span> entityId<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token class-name">String</span> entityLikeKey <span class="token operator">=</span> <span class="token class-name">RedisKeyUtil</span><span class="token punctuation">.</span><span class="token function">getEntityLikeKey</span><span class="token punctuation">(</span>entityType<span class="token punctuation">,</span>entityId<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isMember</span><span class="token punctuation">(</span>entityLikeKey<span class="token punctuation">,</span>userId<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p>处理表现层</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Controller</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LikeController</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> <span class="token class-name">LikeService</span> likeService<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> <span class="token class-name">HostHolder</span> hostHolder<span class="token punctuation">;</span>    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>path <span class="token operator">=</span> <span class="token string">"/like"</span><span class="token punctuation">,</span>method <span class="token operator">=</span> <span class="token class-name">RequestMethod</span><span class="token punctuation">.</span>POST<span class="token punctuation">)</span>    <span class="token annotation punctuation">@ResponseBody</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">like</span><span class="token punctuation">(</span><span class="token keyword">int</span> entityType <span class="token punctuation">,</span><span class="token keyword">int</span> entityId<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">User</span> user <span class="token operator">=</span> hostHolder<span class="token punctuation">.</span><span class="token function">getUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//实现点赞</span>        likeService<span class="token punctuation">.</span><span class="token function">like</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>entityType<span class="token punctuation">,</span>entityId<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//数量</span>        <span class="token keyword">long</span> likeCount <span class="token operator">=</span> likeService<span class="token punctuation">.</span><span class="token function">findEntityLikeCount</span><span class="token punctuation">(</span>entityType<span class="token punctuation">,</span>entityId<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//状态</span>        <span class="token keyword">int</span> status <span class="token operator">=</span> likeService<span class="token punctuation">.</span><span class="token function">findEntityLikeStatus</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>entityType<span class="token punctuation">,</span>entityId<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//用map封装，最后转换成Json发送给给前端页面</span>        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span><span class="token class-name">Object</span><span class="token punctuation">></span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"likeCount"</span><span class="token punctuation">,</span>likeCount<span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"likeStatus"</span><span class="token punctuation">,</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token class-name">CommunityUtil</span><span class="token punctuation">.</span><span class="token function">getJSONString</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">,</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h4 id="实现某个用户的赞"><a href="#实现某个用户的赞" class="headerlink" title="实现某个用户的赞"></a>实现某个用户的赞</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> SPLIT <span class="token operator">=</span> <span class="token string">":"</span><span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> PREFIX_ENTITY_LIKE <span class="token operator">=</span> <span class="token string">"like:entity"</span><span class="token punctuation">;</span>  <span class="token keyword">private</span>  <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> PREFIX_USER_LIKE <span class="token operator">=</span> <span class="token string">"like:user"</span><span class="token punctuation">;</span>  <span class="token comment">//某个实体的赞</span>  <span class="token comment">// like:entity:entitytype:entityId  ->set (userid)      这样可以统计赞的数量和赞的用户</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">getEntityLikeKey</span><span class="token punctuation">(</span><span class="token keyword">int</span> entityType<span class="token punctuation">,</span><span class="token keyword">int</span> entityId<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> PREFIX_ENTITY_LIKE <span class="token operator">+</span> SPLIT <span class="token operator">+</span> entityType<span class="token operator">+</span> SPLIT <span class="token operator">+</span> entityId<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">//某个用户的赞</span>  <span class="token comment">//like:user:userId -> int</span>  <span class="token keyword">public</span> <span class="token keyword">static</span>  <span class="token class-name">String</span> <span class="token function">getUserLikeKey</span><span class="token punctuation">(</span><span class="token keyword">int</span> userId<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> PREFIX_USER_LIKE <span class="token operator">+</span> SPLIT <span class="token operator">+</span> userId <span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p>service层重构，利用事务编写</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">like</span><span class="token punctuation">(</span><span class="token keyword">int</span> userId<span class="token punctuation">,</span> <span class="token keyword">int</span> entityType<span class="token punctuation">,</span> <span class="token keyword">int</span> entityId<span class="token punctuation">,</span> <span class="token keyword">int</span> entityUserId<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>       redisTemplate<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">SessionCallback</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>           <span class="token annotation punctuation">@Override</span>           <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token class-name">RedisOperations</span> operations<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">DataAccessException</span> <span class="token punctuation">&#123;</span>               <span class="token class-name">String</span> entityLikeKey <span class="token operator">=</span> <span class="token class-name">RedisKeyUtil</span><span class="token punctuation">.</span><span class="token function">getEntityLikeKey</span><span class="token punctuation">(</span>entityType<span class="token punctuation">,</span> entityId<span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token class-name">String</span> userLikeKey <span class="token operator">=</span> <span class="token class-name">RedisKeyUtil</span><span class="token punctuation">.</span><span class="token function">getUserLikeKey</span><span class="token punctuation">(</span>entityUserId<span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token keyword">boolean</span> isMember <span class="token operator">=</span> operations<span class="token punctuation">.</span><span class="token function">opsForSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isMember</span><span class="token punctuation">(</span>entityLikeKey<span class="token punctuation">,</span> userId<span class="token punctuation">)</span><span class="token punctuation">;</span>               operations<span class="token punctuation">.</span><span class="token function">multi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token keyword">if</span> <span class="token punctuation">(</span>isMember<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                   operations<span class="token punctuation">.</span><span class="token function">opsForSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>entityLikeKey<span class="token punctuation">,</span> userId<span class="token punctuation">)</span><span class="token punctuation">;</span>                   operations<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">decrement</span><span class="token punctuation">(</span>userLikeKey<span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                   operations<span class="token punctuation">.</span><span class="token function">opsForSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>entityLikeKey<span class="token punctuation">,</span> userId<span class="token punctuation">)</span><span class="token punctuation">;</span>                   operations<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">increment</span><span class="token punctuation">(</span>userLikeKey<span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token punctuation">&#125;</span>               <span class="token keyword">return</span> operations<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token punctuation">&#125;</span>       <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再写一个查询某个用户获得的赞的数量</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 查询某个用户获得的赞</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findUserLikeCount</span><span class="token punctuation">(</span><span class="token keyword">int</span> userId<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">String</span> userLikeKey <span class="token operator">=</span> <span class="token class-name">RedisKeyUtil</span><span class="token punctuation">.</span><span class="token function">getUserLikeKey</span><span class="token punctuation">(</span>userId<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Integer</span> count <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token punctuation">)</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>userLikeKey<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> count <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> count<span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis入门学习</title>
      <link href="/2022/04/18/Redis%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/04/18/Redis%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1.基础知识"></a>1.基础知识</h1><ul><li>Redis的<strong>端口号</strong>为6379</li><li>Redis总共拥有16个数据库，默认使用第0个</li><li>keys *命令 查看所有的key</li><li>flushdb 清除当前数据库</li><li>Redis是<strong>单线程</strong>的（速度快），基于内存操作（所以瓶颈为机器的内存和网络带宽）</li></ul><p>核心：redis将所有数据放在内存中，所以用单线程操作效率最高，而多线程牵扯到cpu的上下文切换（耗时）。<br>xshell连接redis,<strong>在 &#x2F;usr&#x2F;local&#x2F;bin 下</strong></p><pre class="line-numbers language-none"><code class="language-none">[root@VM-4-15-centos bin]# redis-server sjwconfig&#x2F;redis.conf[root@VM-4-15-centos bin]# redis-cli -p 6379127.0.0.1:6379&gt; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="2-五大数据类型"><a href="#2-五大数据类型" class="headerlink" title="2.五大数据类型"></a>2.五大数据类型</h1><h2 id="2-1-String"><a href="#2-1-String" class="headerlink" title="2.1 String"></a>2.1 String</h2><ul><li>append key value 在字符串后面追加value，返回数字，如果key不存在，就相当于set key</li><li>strlen key 返回key的值的字符串长度</li><li>incr key 给这个key的值+1。如果这个key不存在，则相当于set key 1.如果这个key的值不是一个数字，则返回 ERR value is not an integer or out of range。value不是一个数字或超出范围，范围是多大我也不知道，应该是integer的取值范围2147483648。</li><li>decr key 给这个key减一</li><li>incrby key 10 给这个key设置每次增加10，设置步长，指定增量</li><li>decrby key 5 给这个key设置每次自减5.</li><li>getrange key 0 3 获取key对应字符串的部分，相当于java的substring，如果是getranger key 0 -1 则表示获取key的所有&#x3D;GET KEY，而不是截取的部分</li><li>setrange key 2 xx 将字符串中下标为2的值替换为xx，例如set key1 abcde setrange key1 2 xx get key1返回abxxcd。相当于java的replace</li><li>setex key second value 表示设置后多少秒过期，seconds表示过期时间。ex就是expire</li><li>setnx key value 表示如果这个key不存在才设置，如果存在则不设置。nx就是 not exist</li><li>mset k1 v1 k2 v2 k3 v3 … 表示同时设置多个键值对</li><li>mget k1 k2 k3 同时获取多个</li><li>msetnx k1 v1 k2 v2 k3 v3 k4 v4.. 如果不存在则设置，如果key有一个存在的，则所有的都设置不成功。这是一个原子性的操作，<strong>redis的事务是不保证原子性操作的，但是msetnx是保证原子性操作的</strong>。</li><li>getset key value 先get 再set，当key不存在时，返回null 并设置这个key和value，当key存在时，返回key的值并用value覆盖之前的value</li></ul><p><strong>string类型的使用场景</strong>，value除了可以是字符串还可以是数字，因此可以用到以下场景：</p><ul><li><p>计数器：比如浏览量、粉丝数等等，当该对象被浏览了之后，可以使用incr articleid title；或者粉丝数 incr userid fans 或decr</p><h2 id="2-2-List"><a href="#2-2-List" class="headerlink" title="2.2 List"></a>2.2 List</h2><p>在redis中可以将List作为一个栈、队列、阻塞队列来实现。<br>所有的命令都是用L开头的,<strong>不区分大小写命令</strong></p></li><li><p>Lpush list  1 2 3 给list左边添加一个或多个元素</p></li><li><p>Rpush list  v1 v2 v3… 给list右边添加一个或多个元素</p></li><li><p>Lpop list 从列表的左边弹出一个元素</p></li><li><p>Rpop list 从列表的右边弹出一个元素，弹出后元素内容-1</p></li><li><p>Lindex list 0 获取list中下标为0的元素</p></li><li><p>Llen list 获取list长度</p></li><li><p>Lrem list count value表示移除list中count个value元素。</p></li><li><p>Ltrim list start stop 表示根据下标截取队列</p></li><li><p>rpoplpush list1 list2 将list1中最后一个元素移除，并将其放入list2中</p></li><li><p>lset 将列表中指定下标的值替换为另一个值，更新操作，如果列表不存在或下标不存在会报错</p></li><li><p>Linsert list befor&#x2F;after value newvalue 往list中的value的before或after插入一个newvalue处插入一个值。</p></li></ul><p><strong>Lpush Rpop 左边进右边出，这是一个队列；Lpush Lpop 左边进左边出，这是一个栈</strong></p><h2 id="2-3-Set"><a href="#2-3-Set" class="headerlink" title="2.3 Set"></a>2.3 Set</h2><p><strong>set不能重复(无序)</strong></p><ul><li>sadd set v1 v2 v3…. 往set集合中添加一个或多个元素，重复元素只能添加进一个</li><li>smembers set 获取所有元素</li><li>sismember set value 判断value是否存在</li><li>scard set 获取set中元素的个数</li><li>srem set value 将value移除set集合</li><li>srandmember set count 随机返回count个数的元素，count默认1</li><li>spop set count 从set中随机移除一个或count个元素</li><li>smove set newset member将set中的指定元素移动到newset中</li></ul><p>应用场景：<br>微博、b站 共同关注（交集）</p><ul><li><p>sdiff set1 set2 差集</p></li><li><p>sinter set1 set2交集 共同关注就可以这么实现</p></li><li><p>sunion set1 set2并集</p><h2 id="2-4-Hash"><a href="#2-4-Hash" class="headerlink" title="2.4 Hash"></a>2.4 Hash</h2></li><li><p>hset hash key value key1 value1 … 与string类似，命令以H开头，只不过值是k-v</p></li><li><p>hget hash key1 key2…</p></li><li><p>hmset hash key value key1 value1 … 多个操作</p></li><li><p>hmget hash key1 key2…</p></li><li><p>hgetall hash 获取所有的键值对</p></li><li><p>hdel hash key 删除指定的key的字段，对应的value也就没有了</p></li><li><p>hlen hash获取这个hash中有多少个键值对</p></li><li><p>hexists hsah key判断这个key是否存在</p></li><li><p>hkeys hash 获取所有key</p></li><li><p>hvals hash 获取所有value</p></li><li><p>hincrby hash key 1自增</p></li><li><p>hdecrby hash key 1自减</p></li><li><p>hsetnx hash key 如果不存在可以设置，如果存在，则不能设置<br>保存变更的数据，可以将一个用户变形为hashset hash user:id:name zhangsan，因此hash更适合存储对象，而string比较适合存储字符串</p><h2 id="2-5-Zset-有序集合"><a href="#2-5-Zset-有序集合" class="headerlink" title="2.5 Zset(有序集合)"></a>2.5 Zset(有序集合)</h2></li><li><p>zadd key 序号 value</p></li><li><p>zrange zset 0 -1</p></li><li><p>zrangebyscore key -inf +inf</p></li><li><p>zrem key member</p></li><li><p>zcard key</p></li><li><p>zcount  key start stop  获取指定区间的成员数量</p><h1 id=""><a href="#" class="headerlink" title=""></a></h1></li></ul><h1 id="3-三种特殊数据类型"><a href="#3-三种特殊数据类型" class="headerlink" title="3.三种特殊数据类型"></a>3.三种特殊数据类型</h1><h2 id="3-1-geospatial-地理位置"><a href="#3-1-geospatial-地理位置" class="headerlink" title="3.1 geospatial 地理位置"></a>3.1 geospatial 地理位置</h2><p>朋友的定位，附近的 人，打车距离，比如两地之间的距离等等<br>共六个命令</p><ul><li>geoadd key 维度 经度 名称 添加地理位置。南北极无法添加，一般会下载城市地理数据，使用java程序一次性导入，例子GEOADD Sicily 13.361389 38.115556 “Palermo” 15.087269 37.502669 “Catania”。经度和维度的范围超出会报错</li><li>geopos获取指定的城市的经度和维度</li><li>geodist<br>m 表示单位为米。<br>km 表示单位为千米。<br>mi 表示单位为英里。<br>ft 表示单位为英尺。<br>如果用户没有显式地指定单位参数， 那么 GEODIST 默认使用米作为单位。</li><li>georadius 如图，显示110 30 这个经纬度周围500km的城市<br><img src="https://cdn.nlark.com/yuque/0/2022/png/26758626/1650024795893-c1eb5b8a-cd59-4089-9a9d-ccad3d160c55.png#clientId=u77687043-8319-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u7d4449a7&margin=%5Bobject%20Object%5D&name=image.png&originHeight=79&originWidth=493&originalType=url&ratio=1&rotation=0&showTitle=false&size=31405&status=done&style=none&taskId=ub42a10a2-820b-4bc2-9bde-468be7c474e&title=" alt="image.png">附近的人的原理就是这个，当我们将所有用户的位置信息加入redis后，某个用户查看周围范围（可指定）多少人（可指定）</li><li>georadiusbymember找出位于指定范围内的元素，中心点是由给定的位置元素决定</li><li>geohash 了解一下 返回一个或多个位置元素的 Geohash 表示</li></ul><p><strong>geo的底层实现是基于zset，因此我们可以使用zset的命令来操作geo的元素</strong></p><h2 id="3-2-Hyperloglog-基数统计"><a href="#3-2-Hyperloglog-基数统计" class="headerlink" title="3.2 Hyperloglog 基数统计"></a>3.2 Hyperloglog 基数统计</h2><p>简介：<br>    Redis2.5.9版本更新了Hyperloglog数据结构<br>    应用场景：<strong>统计网站访问量</strong>，同一个人多次访问也只计做一次<br>传统的做法：使用set保存用户id，计算set的size，<strong>这个方法的缺点就是耗费内存</strong>，并且我们的主要目的是计算访问量，而不是保存id<br>使用Hyperloglog：<strong>内存占用小</strong>，2^64的数据仅占用12KB；错误率0.81%很低，基本上可以忽略不计</p><pre><code> 命令如下图：</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26758626/1650026278568-6fe6dc46-2cc8-4c11-a48b-70ec3eff47ad.png#clientId=u77687043-8319-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u91010860&margin=%5Bobject%20Object%5D&name=image.png&originHeight=215&originWidth=593&originalType=url&ratio=1&rotation=0&showTitle=false&size=103555&status=done&style=none&taskId=u437f4dfb-33ae-44f5-87d4-429a395fba0&title=" alt="image.png"></p><h2 id="3-3-Bitmaps"><a href="#3-3-Bitmaps" class="headerlink" title="3.3 Bitmaps"></a>3.3 Bitmaps</h2><h4 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h4><p>统计用户信息，活跃、不活跃，登录、未登录，打卡，两种状态的都可以使用BitMap</p><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>Bitmap 位图，使用二进制来进行记录，只有0和1两个状态的都可以这么做</p><h1 id="4-redis事务操作"><a href="#4-redis事务操作" class="headerlink" title="4.redis事务操作"></a>4.redis事务操作</h1><p>Redis的事物中<strong>不保证原子性</strong>，但是Redis的<strong>单条命令是保证原子性</strong>的</p><hr><p>Redis事物的本质：<br>Redis会将一组命令保存在一个队列中，然后顺序执行，在事物中命令都会被序列化，并且是一次性全部执行完毕，不允许被打断。<br>redis的事物：</p><ul><li>开启事物：multi</li><li>命令入队：</li><li>执行事物：execu</li></ul><p> -放弃事物：discard<br><img src="https://cdn.nlark.com/yuque/0/2022/png/26758626/1650111442840-7d09e438-4e16-478b-b4e5-3c6c4262c705.png#clientId=u22d88724-ae18-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=398&id=u8d20da64&margin=%5Bobject%20Object%5D&name=image.png&originHeight=422&originWidth=401&originalType=binary&ratio=1&rotation=0&showTitle=false&size=8979&status=done&style=none&taskId=u3b238bcf-1dc0-4495-9575-2b1e07d6cfa&title=&width=378" alt="image.png"><br>异常：</p><ul><li>编译时异常：命令错误，在程序启动时就会报错，所有命令都不执行</li><li>运行时异常：抛出异常，其他命令执行</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26758626/1650111749757-56cdd771-3d54-4854-aeec-93bcd768acb2.png#clientId=u22d88724-ae18-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u490edf84&margin=%5Bobject%20Object%5D&name=image.png&originHeight=315&originWidth=569&originalType=url&ratio=1&rotation=0&showTitle=false&size=109673&status=done&style=none&taskId=uf7087ec5-a5e1-4543-a963-438953bcf8b&title=" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26758626/1650111783904-f47b0a1f-e0a0-47b7-b416-9788f101054c.png#clientId=u22d88724-ae18-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ub2e275f6&margin=%5Bobject%20Object%5D&name=image.png&originHeight=380&originWidth=709&originalType=url&ratio=1&rotation=0&showTitle=false&size=102322&status=done&style=none&taskId=uc4931ef8-8bd5-4f69-bdcd-12dfc6fcc3a&title=" alt="image.png"></p><h1 id="5-Redis锁："><a href="#5-Redis锁：" class="headerlink" title="5. Redis锁："></a>5. Redis锁：</h1><p>锁：</p><ul><li>悲观锁：认为任何时候都有可能出问题，因此在任何时候都要加锁</li><li>乐观锁：认为 一般不会出问题，所以不上锁。只有在特定的时候才上</li><li>使用watch实现乐观锁<br>举例：如下图，当我们有一个存款为100的时候，开启监视watch命令，然后开启事物，执行消费二十，然后给支出项增加二十，或者余额减去二十，然后提交事物，执行命令，这个时候是正常执行的没有问题。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26758626/1650112193172-e538c453-dfdc-4fdb-9d18-f436a552af5b.png#clientId=u22d88724-ae18-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=320&id=uec6afa98&margin=%5Bobject%20Object%5D&name=image.png&originHeight=320&originWidth=635&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11041&status=done&style=none&taskId=ue8921f2d-27f9-4174-92b8-9e2120fb097&title=&width=635" alt="image.png"><br>当出现如下情况的时候，首先监视money，这个时候它的值是100，然后开启事物，消费10块钱，支出项增加10，然后在exec命令执行之前，另一个线程中修改了money的值，这个时候exec执行的时候发现money的值已经改变了，就会返回一个null，表示事物执行失败<br>    <img src="https://cdn.nlark.com/yuque/0/2022/png/26758626/1650112230147-a24271ab-34cc-402e-a256-d604e631ec59.png#clientId=u22d88724-ae18-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u9018c233&margin=%5Bobject%20Object%5D&name=image.png&originHeight=187&originWidth=578&originalType=url&ratio=1&rotation=0&showTitle=false&size=56825&status=done&style=none&taskId=uf300b9b3-40cc-454a-9d4f-a7955371c76&title=" alt="image.png"><br>那么如何解决这个问题呢？首先使用UNwatch命令解锁，将刚才出异常的锁释放掉，然后重新给 money加锁，重新开启事物，加入命令到队列，再exec，这个时候获取到的就是最新的money。<img src="https://cdn.nlark.com/yuque/0/2022/png/26758626/1650112230178-f7bdc262-f33b-465c-b9d7-d41745d7b80c.png#clientId=u22d88724-ae18-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uf51724d8&margin=%5Bobject%20Object%5D&name=image.png&originHeight=211&originWidth=565&originalType=url&ratio=1&rotation=0&showTitle=false&size=101817&status=done&style=none&taskId=uc41fb9ce-938a-4fb3-995e-16bb7b6cd8b&title=" alt="image.png"></p><h1 id="6-Jedis"><a href="#6-Jedis" class="headerlink" title="6. Jedis"></a>6. Jedis</h1><p>什么是jedis？<br>    jedis是Redis官方推荐的java连接开发工具，使用java操作redis中间件，在springboot中使用redisTemplate操作，但是还是要对jedis十分了解才行。</p><h2 id="6-1导入maven依赖"><a href="#6-1导入maven依赖" class="headerlink" title="6.1导入maven依赖"></a>6.1导入maven依赖</h2><pre class="line-numbers language-none"><code class="language-none">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot;xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;&lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;&lt;groupId&gt;org.example&lt;&#x2F;groupId&gt;&lt;artifactId&gt;RedisDemo&lt;&#x2F;artifactId&gt;&lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;&lt;dependencies&gt;&lt;dependency&gt;&lt;groupId&gt;redis.clients&lt;&#x2F;groupId&gt;&lt;artifactId&gt;jedis&lt;&#x2F;artifactId&gt;&lt;version&gt;2.9.0&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt;&lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;&lt;artifactId&gt;fastjson&lt;&#x2F;artifactId&gt;&lt;version&gt;1.2.74&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt;&lt;properties&gt;&lt;maven.compiler.source&gt;11&lt;&#x2F;maven.compiler.source&gt;&lt;maven.compiler.target&gt;11&lt;&#x2F;maven.compiler.target&gt;&lt;&#x2F;properties&gt;&lt;&#x2F;project&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-2-编码测试"><a href="#6-2-编码测试" class="headerlink" title="6.2 编码测试"></a>6.2 编码测试</h2><ul><li>连接数据库</li><li>操作命令</li><li>断开连接</li></ul><p>测试连接</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestPing</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//new Jedis 对象</span>        <span class="token class-name">Jedis</span> jedis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Jedis</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">,</span><span class="token number">6379</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//jedis 的所有命令就是之前学习的命令</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>jedis<span class="token punctuation">.</span><span class="token function">ping</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-3-事务"><a href="#6-3-事务" class="headerlink" title="6.3 事务"></a>6.3 事务</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>sjw</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">com<span class="token punctuation">.</span>alibaba<span class="token punctuation">.</span>fastjson<span class="token punctuation">.</span></span><span class="token class-name">JSONObject</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">netscape<span class="token punctuation">.</span>javascript<span class="token punctuation">.</span></span><span class="token class-name">JSObject</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">redis<span class="token punctuation">.</span>clients<span class="token punctuation">.</span>jedis<span class="token punctuation">.</span></span><span class="token class-name">Jedis</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">redis<span class="token punctuation">.</span>clients<span class="token punctuation">.</span>jedis<span class="token punctuation">.</span></span><span class="token class-name">Transaction</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestTX</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Jedis</span> jedis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Jedis</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">,</span><span class="token number">6379</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">JSONObject</span> jsonObject <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JSONObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        jsonObject<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">,</span><span class="token string">"world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        jsonObject<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">,</span><span class="token string">"sjw"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        jedis<span class="token punctuation">.</span><span class="token function">flushDB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//开启事务</span>        <span class="token class-name">Transaction</span> multi <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">multi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> result <span class="token operator">=</span> jsonObject<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span><span class="token punctuation">&#123;</span>            multi<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"user1"</span><span class="token punctuation">,</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>            multi<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"user2"</span><span class="token punctuation">,</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">0</span><span class="token punctuation">;</span>   <span class="token comment">//代码抛出异常，执行失败</span>            multi<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">//放弃事务</span>            multi<span class="token punctuation">.</span><span class="token function">discard</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>jedis<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"user1"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            jedis<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="7-SpringBoot-集成-Redis"><a href="#7-SpringBoot-集成-Redis" class="headerlink" title="7. SpringBoot 集成 Redis"></a>7. SpringBoot 集成 Redis</h1><p>在springboot2.x之后，原来使用的jedis被替换为lettuce，为什么替换呢？<br>redis：采用直连的方式，多线程操作不安全，如果想要避免不安全，就要使用<strong>jedis pool连接池</strong>，类似<strong>BIO</strong>模型 ，是阻塞的。<br>lettuce：采用netty，实例可以在多个线程中共享，不存在线程不安全情况，更像<strong>NIO</strong>模型</p><p><strong>步骤：</strong></p><ul><li>导入依赖<br>在maven仓库或者spring官网都可以找到整个redis的依赖，加入启动器spring-boot-starter-data-redis，这个启动器底层是使用的spring-data-redis来连接redis的，springData也是spring的一个大型项目，包括jpa、jdbc、MongoDB、redis都是使用springdata进行连接。</li><li>配置连接<br>我们知道在springboot中有自动配置类和对应的properties类，这两个类帮助springBoot快速构建组件，这里我们说一下springBoot整合Redis的源码分析</li></ul><p>操作</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@SpringBootTest</span><span class="token keyword">class</span> <span class="token class-name">RedisSpringbootApplicationTests</span> <span class="token punctuation">&#123;</span>        <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> <span class="token class-name">RedisTemplate</span> redisTemplate<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">void</span> <span class="token function">contextLoads</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//springboot 中opsForxxx即表示操作某个类型，如下：</span>        redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//操作string类型</span>        redisTemplate<span class="token punctuation">.</span><span class="token function">opsForList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//操作List类型</span>        redisTemplate<span class="token punctuation">.</span><span class="token function">opsForHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//操作map类型</span>        redisTemplate<span class="token punctuation">.</span><span class="token function">opsForSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//操作set类型</span>        <span class="token comment">//还有一些常用的操作，可以直接用redisTemplate进行</span>        redisTemplate<span class="token punctuation">.</span><span class="token function">multi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//开启事务</span>        redisTemplate<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//执行事务</span><span class="token comment">//        redisTemplate.watch();//开启乐观锁</span>        redisTemplate<span class="token punctuation">.</span><span class="token function">discard</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//关闭事务</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="8-redis配置详解"><a href="#8-redis配置详解" class="headerlink" title="8. redis配置详解"></a>8. redis配置详解</h1><p>redis的配置文件redis.conf，这个文件中使用################### 模块名############## 这种方式将各个配置项分割开来，具体如下：</p><ul><li>单位配置：不知道这玩意是干啥的，一般不动。配置大小写不敏感</li><li>INCLUDES，包含，意思就是可以把其他配置文件包含进来组成一个配置文件，这在你有标准配置模板但是每个redis服务器又需要个性设置的时候很有用。并且include 配置最好放在配置文件的最后一行？<ul><li><h1 id="include-path-to-local-conf"><a href="#include-path-to-local-conf" class="headerlink" title="include .\path\to\local.conf"></a>include .\path\to\local.conf</h1></li><li><h1 id="include-c-path-to-other-conf"><a href="#include-c-path-to-other-conf" class="headerlink" title="include c:\path\to\other.conf"></a>include c:\path\to\other.conf</h1></li></ul></li><li>NETWORK 网络配置<ul><li>bind 127.0.0.1 绑定的ip</li><li>protected-mode yes 是否保护模式</li><li>port 6379 端口设置</li><li>timeout 0</li></ul></li><li>GENERAL 通用<ul><li>loglevel notice 日志级别<ul><li>debug (a lot of information, useful for development&#x2F;testing) 开发或测试时用</li><li>verbose (many rarely useful info, but not a mess like the debug level) 一些常用的信息</li><li>notice (moderately verbose, what you want in production probably) 生产模式使用</li><li>warning (only very important &#x2F; critical messages are logged) 只打印一些重要的 信息</li></ul></li><li>daemonize no 是否设置为守护进程，Windows中不支持该配置。默认yes</li><li>supervised no</li><li>pidfile &#x2F;var&#x2F;run&#x2F;redis.pid 如果以守护进程的方式运行，就需要指定这个pid文件，不知道有什么用</li><li>logfile “” 日志文件保存路径</li><li>databases 16 默认一共16个数据库</li><li>always-show-logo yes 启动时是否显示logo</li></ul></li><li>SNAPSHOTTING 快照，快照分rdb和aof<ul><li>save “” 持久化操作的策略<ul><li>save 900 1 如果900秒内有一次key进行了更新，则持久化一次</li><li>save 300 10 如果300秒内有10 key进行了更新，则持久化一次</li><li>save 60 10000 如果60秒 内有至少10000个key进行了更新，则持久化一次。一般情况我们不会使用这几种方式，一般都是</li></ul></li><li>stop-writes-on-bgsave-error yes 如果持久化过程出现错误，是否还要继续</li><li>rdbcompression yes 是否压缩rdb文件，需要消耗一些CPU资源</li><li>rdbchecksum yes 保存rdb文件的时候，进行错误的检查校验</li><li>dir .&#x2F; rdb文件保存的目录，默认当前目录下</li><li>dbfilename dump.rdb rdb文件的名字，默认dump</li></ul></li><li>REPLICATION 主从复制</li><li>SECURITY 安全 <strong>默认没有密码</strong> vm_redis:0&gt;config get requirepass  &#x2F;&#x2F;获取密码   1)  “requirepass”  2)  “” vm_redis:0&gt;config set requirepass 123456  &#x2F;&#x2F;设置密码 “OK” vm_redis:0&gt;config get requirepass   1)  “requirepass”  2)  “123456” vm_redis:0&gt;ping “PONG” vm_redis:0&gt;auth 123456  &#x2F;&#x2F;使用密码登录 “OK” 123456789101112<ul><li>requirepass foobared 设置密码，也可以使用如下命令</li></ul></li><li>CLIENTS 客户端配置<ul><li>maxclients 10000 最大允许一万个客户端连接</li><li>**maxmemory **配置redis的最大内存容量</li><li>maxmemory-policy noeviction 内存达到上限后的回收策略从已经设置了过期时间的key中去选择<ul><li>noeviction： 默认的策略，即当内存使用达到阈值的时候，所有引起申请内存的命令都会报错；</li><li><strong>allkeys-lru</strong>：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰 。<br>适用场景： 如果我们的应用对缓存的访问都是相对热点数据，就可以选择这个策略；</li><li>allkeys-random：随机移除某个key。<br>适合的场景：如果我们的应用对于缓存key的访问概率相等，则可以使用这个策略。</li><li>volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰。</li><li>volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰。</li><li>volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰；适合场景：这种策略使我们可以向Redis提示哪些key更适合被淘汰，可以自己控制 。</li></ul></li></ul></li><li>APPEND ONLY 模式 aof配置（了解，大部分情况下rdb已经足够使用，aof是对rdb的一个补充，并且性能不高，因此使用少）<ul><li>appendonly no** 默认不开启aof模式**，如果我们要启用aof，一般情况下只需要将该项配置改为yes即可</li><li>appendfilename “appendonly.aof” aof持久化文件的名字</li><li>appendfsync<ul><li>appendfsync always 每次修改都会同步，消耗性能</li><li>appendfsync everysec 每秒执行一次同步sync，可能会丢失这一秒的数据</li><li>appendfsync no 不执行同步，速度快</li></ul></li><li>no-appendfsync-on-rewrite no 保持默认即可</li><li>xxx-rewrite-xxx 重写配置（了解，一般不做修改）<ul><li>例如64M，就是说aof会一直将写操作命令追加进aof文件中，如果文件大小超过了这个64m，就会生成一个新的 文件<h1 id="9-Redis持久化"><a href="#9-Redis持久化" class="headerlink" title="9. Redis持久化"></a>9. Redis持久化</h1><h2 id="9-1-RDB"><a href="#9-1-RDB" class="headerlink" title="9.1 RDB"></a>9.1 RDB</h2>redis 是内存数据库，断电及失，因此需要持久化，默认使用RDB，一般情况下我们无需修改RDB配置，即可使用。<br>Redis会单独创建一个fork子进程来进行持久化，子进程中循环所有的数据，将数据写入到二进制文件中，会先将数据 写入到一个临时文件中，待持久化过程都结束了，在用这个临时文件替换上次持久化好了的文件。整个过程中，主进程是不进行任何IO操作的，确保极高的性能，如果需要进行大规模数据的回复，且对数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加高效。<strong>RDB的缺点就是最后一次持久化后的数据可能丢失。</strong></li></ul></li></ul></li></ul><p><strong>RDB保存的文件就是dump.rdb</strong><br><strong>当我们修改了配置文件后，直接使用save命令就可以保存修改</strong><br><strong>1.触发机制</strong><br>(1)save的规则满足的情况下，会自动触发rdb规则<br>(2)执行 flushall 命令，也会触发我们的rdb规则！<br>(3)退出redis，也会产生 rdb 文件！<br>备份就自动生成一个 dump.rdb</p><p><strong>2.如何恢复rdb文件？</strong><br>(1)只需要将rdb文件放在我们redis启动目录就可以，redis启动的时候会自动检查dump.rdb 恢复其中的数据！<br>(2)查看需要存在的位置<br>127.0.0.1:6379&gt; config get dir </p><ol><li>“dir” </li><li>“&#x2F;usr&#x2F;local&#x2F;bin” # 如果在这个目录下存在 dump.rdb 文件，启动就会自动恢复其中的数据</li></ol><p>几乎Redis的默认配置就够用了，但是我们还是需要去学习！<br><strong>RDB优点：</strong><br>1、适合大规模的数据恢复！<br>2、对数据的完整性要不高！</p><p><strong>RDB缺点：</strong><br>1、需要一定的时间间隔进程操作！如果redis意外宕机了，这个最后一次修改数据就没有的了！<br>2、fork进程的时候，会占用一定的内容空间<br><a href="https://blog.51cto.com/zhangzhixi/3175577"></a></p><h2 id="9-2-AOF（Append-Only-File）"><a href="#9-2-AOF（Append-Only-File）" class="headerlink" title="9.2 AOF（Append Only File）"></a>9.2 AOF（Append Only File）</h2><p>将我们的所有命令都记录下来，history，恢复的时候就把这个文件全部在执行一遍！</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26758626/1650210740913-b53e2d50-e1aa-4042-ac7e-bb8d009f9375.png#clientId=u8a2ba187-a65d-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u0084cf48&margin=%5Bobject%20Object%5D&originHeight=776&originWidth=999&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uc6033a2a-750b-4931-85fa-77817e76e14&title="></p><p>以日志的形式来记录每个写操作，将Redis执行过的所有指令记录下来（读操作不记录），只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作<br>Aof保存的是 appendonly.aof 文件</p><hr><p>append<br><img src="https://cdn.nlark.com/yuque/0/2022/png/26758626/1650210770377-366e2ea1-bb26-4d0b-9ead-faffedf82f40.png#clientId=u8a2ba187-a65d-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u44cf95c3&margin=%5Bobject%20Object%5D&originHeight=572&originWidth=1113&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u95fea192-c76e-4d7c-a876-e8a12c29965&title="><br>默认是不开启的，我们需要手动进行配置！我们只需要将 appendonly 改为yes就开启了 aof！<br>重启，redis 就可以生效了！<br>如果<strong>这个 aof 文件有错误，这时候 redis 是启动不起来的</strong>，我们需要修复这个aof文件<br>redis 给我们提供了一个工具 redis-check-aof –fix<br><img src="https://cdn.nlark.com/yuque/0/2022/png/26758626/1650210795417-be20bd78-178a-4b36-838f-1031a4878220.png#clientId=u8a2ba187-a65d-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u07f4fc2f&margin=%5Bobject%20Object%5D&originHeight=197&originWidth=1194&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u9fc3803b-8528-4d8d-ab83-931279ec6c0&title="><br> 如果文件正常，重启就可以直接恢复了！<br><img src="https://cdn.nlark.com/yuque/0/2022/png/26758626/1650210813030-8d378904-7213-461f-93dd-2c24c6ba0c0d.png#clientId=u8a2ba187-a65d-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u0251cbb3&margin=%5Bobject%20Object%5D&originHeight=345&originWidth=1184&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uc0e122d1-7f93-45b4-9523-11a3e6c6615&title="></p><hr><p><strong>重写规则说明</strong></p><p>aof 默认就是文件的无限追加，文件会越来越大！<br><img src="https://cdn.nlark.com/yuque/0/2022/png/26758626/1650210846808-0286e3e4-d46d-4ede-80a4-322844459466.png#clientId=u8a2ba187-a65d-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uda9ab224&margin=%5Bobject%20Object%5D&originHeight=665&originWidth=1110&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u59783648-68d5-40b9-a960-839e96070f4&title="><br>如果 aof 文件大于 64m，太大了！ fork一个新的进程来将我们的文件进行重写！</p><hr><p><strong>AOF优点</strong>：</p><ul><li>每次修改都同步，文件的完成性会更好</li><li>每秒同步一次，<strong>可能会丢失最后一秒数据</strong></li><li>从不同步，效率最高</li></ul><p><strong>AOF缺点：</strong></p><ul><li>相对于rdb，aof远大于rdb，修复速度也比rdb慢</li><li>aof运行效率也比rdb慢，因此默认rdb</li></ul><p>扩展：<br>1、RDB 持久化方式能够在指定的时间间隔内对你的数据进行快照存储<br>2、AOF 持久化方式记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据，AOF命令以Redis 协议追加保存每次写的操作到文件末尾，Redis还能对AOF文件进行后台重写，使得AOF文件的体积不至于过大。<br>3、只做缓存，如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化<br>4、同时开启两种持久化方式<br>在这种情况下，当redis重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。RDB 的数据不实时，同时使用两者时服务器重启也只会找AOF文件，那要不要只使用AOF呢？作者建议不要，因为RDB更适合用于备份数据库（AOF在不断变化不好备份），快速重启，而且不会有AOF可能潜在的Bug，留着作为一个万一的手段。<br>5、性能建议<br>因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留 save 900 1 这条规则。如果Enable AOF ，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了，代价一是带来了持续的IO，二是AOF rewrite 的最后将 rewrite 过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少AOF rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上，默认超过原大小100%大小重写可以改到适当的数值。如果不Enable AOF ，仅靠 Master-Slave Repllcation 实现高可用性也可以，能省掉一大笔IO，也减少了rewrite时带来的系统波动。代价是如果Master&#x2F;Slave 同时倒掉，会丢失十几分钟的数据，启动脚本也要比较两个 Master&#x2F;Slave 中的 RDB文件，载入较新的那个，微博就是这种架构。</p><h1 id="10-订阅发布"><a href="#10-订阅发布" class="headerlink" title="10. 订阅发布"></a>10. 订阅发布</h1><p>Redis 发布订阅(pub&#x2F;sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。微信、微博、关注系统！<br>Redis 客户端可以订阅任意数量的频道。</p><p>订阅&#x2F;发布消息图：<br>第一个：消息发送者， 第二个：频道 第三个：消息订阅者！<a href="https://blog.51cto.com/zhangzhixi/3175577"></a><img src="https://cdn.nlark.com/yuque/0/2022/png/26758626/1650285249827-42117319-aa8e-481c-978a-4330a27026f5.png#clientId=ue836c7aa-ce6f-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u8ea750d8&margin=%5Bobject%20Object%5D&originHeight=451&originWidth=1088&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u79c7a054-4705-4ff8-a8a7-e9600ff51ff&title="></p><p>下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的关系：</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26758626/1650285282271-8a14c418-37eb-4053-96b1-3670c730e8aa.png#clientId=ue836c7aa-ce6f-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u4fa7b9b7&margin=%5Bobject%20Object%5D&originHeight=358&originWidth=591&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ue61e377f-69e0-4b87-8db6-28e400009f1&title="></p><p> 当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/26758626/1650285297639-b3e7d68f-3b8b-4adf-92a6-2635b6ad31dc.png#clientId=ue836c7aa-ce6f-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ue57afe77&margin=%5Bobject%20Object%5D&originHeight=518&originWidth=584&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ue13445e1-071c-4f5d-8e53-b1136af6573&title="></p><hr><p><strong>命令</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/26758626/1650285325585-999f5581-ff58-4d55-aa21-d974734a0de3.png#clientId=ue836c7aa-ce6f-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u61d0163e&margin=%5Bobject%20Object%5D&originHeight=632&originWidth=578&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ud1c69843-079f-45cd-b781-08d1e841a38&title="></p><h1 id="11-主从复制"><a href="#11-主从复制" class="headerlink" title="11. 主从复制"></a>11. 主从复制</h1><p>主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master&#x2F;leader)，后者称为从节点(slave&#x2F;follower)；数据的复制是单向的，只能由主节点到从节点。<br>Master以写为主，Slave 以读为主。<br>　　<strong>默认情况下，每台Redis服务器都是主节点；</strong><br>且一个主节点可以有多个从节点(或没有从节点)，但一个从节点只能有一个主节点。</p><p><strong>主从复制的作用主要包括：</strong><br>1、数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。<br>2、故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。<br>3、负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。<br>4、高可用（集群）基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。<br>一般来说，要将Redis运用于工程项目中，只使用一台Redis是万万不能的（宕机），原因如下：<br>1、从结构上，单个Redis服务器会发生单点故障，并且一台服务器需要处理所有的请求负载，压力较大；<br>2、从容量上，单个Redis服务器内存容量有限，就算一台Redis服务器内存容量为256G，也不能将所有内存用作Redis存储内存，一般来说，单台Redis最大使用内存不应该超过20G。<br>电商网站上的商品，一般都是一次上传，无数次浏览的，说专业点也就是”多读少写”。</p><p>对于这种场景，我们可以使如下这种架构：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/26758626/1650286930592-6c5af5e6-2a3d-419a-ba2e-3a4cb15335ab.png#clientId=ue836c7aa-ce6f-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u223a61ea&margin=%5Bobject%20Object%5D&originHeight=724&originWidth=1099&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ued1825c9-1ce9-44e7-8f49-1ad8325ae57&title="><br>主从复制，读写分离！ 80% 的情况下都是在进行读操作！减缓服务器的压力！架构中经常使用！ 一主二从！</p><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p><strong>只配置从库，不用配置主库！</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/26758626/1650287001813-3cd41d83-3f0a-4ed0-a13f-4f858e3b0a9b.png#clientId=ue836c7aa-ce6f-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=698&id=u8695758a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=698&originWidth=1220&originalType=binary&ratio=1&rotation=0&showTitle=false&size=122007&status=done&style=none&taskId=u3118214a-9007-41cd-ab04-931d854eb17&title=&width=1220" alt="image.png"></p><h2 id="一主二从"><a href="#一主二从" class="headerlink" title="一主二从"></a>一主二从</h2><p><strong>默认情况下，每台redis服务器都是主节点！！</strong></p><p>认老大！ 一主 （79）二从（80，81）<br><img src="https://cdn.nlark.com/yuque/0/2022/png/26758626/1650287086432-e858ec80-a0ed-4224-b49e-9471bcc581cc.png#clientId=ue836c7aa-ce6f-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ubb8d6bbf&margin=%5Bobject%20Object%5D&originHeight=460&originWidth=817&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ud5bd7a52-cdd3-421e-a145-92098c42059&title="><br><img src="https://cdn.nlark.com/yuque/0/2022/png/26758626/1650287103949-ef5df0ff-a685-4af4-8bc7-c5742545a14c.png#clientId=ue836c7aa-ce6f-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=749&id=u1a64211d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=749&originWidth=1092&originalType=binary&ratio=1&rotation=0&showTitle=false&size=80399&status=done&style=none&taskId=u5b69e22c-c48f-4e7b-a414-08cdf6effaf&title=&width=1092" alt="image.png"></p><hr><p><strong>注意</strong><br>主机可以写，从机不能写只能读！主机中的所有信息和数据，都会自动被从机保存！<br>主机写：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/26758626/1650287146573-e3fa37f9-7396-48ef-8646-4cfa19151e38.png#clientId=ue836c7aa-ce6f-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u516ae957&margin=%5Bobject%20Object%5D&originHeight=116&originWidth=628&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ud4add2bc-61e5-4d96-a3b0-ce8adba7084&title="><br>从机只能读取，不能写入：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/26758626/1650287161547-625d9c89-1713-40ce-94d8-90a21437b1eb.png#clientId=ue836c7aa-ce6f-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uc02ee335&margin=%5Bobject%20Object%5D&originHeight=176&originWidth=661&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uead97089-5cf5-4232-9850-d5946f3fd66&title="><br>测试：主机断开连接，<strong>从机依旧连接到主机的，但是没有写操作</strong>，这个时候，主机如果回来了，从机依旧可以直接获取到主机写的信息！</p><p>如果是使用命令行，来配置的主从，这个时候如果重启了，从机就会变回主机，与之前的主机断开连接！<br><strong>只要再变为从机，立马就会从主机中获取值！</strong></p><h1 id="12-哨兵模式"><a href="#12-哨兵模式" class="headerlink" title="12. 哨兵模式"></a>12. 哨兵模式</h1><p>　主从切换技术的方法是：当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。这不是一种推荐的方式，更多时候，我们优先考虑哨兵模式。</p><p>Redis从2.8开始正式提供了Sentinel（哨兵） 架构来解决这个问题。<br>谋朝篡位的自动版，能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库。</p><p>哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独立运行。其原理是哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例。<br>这里的哨兵有两个作用</p><p>通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器。<br>当哨兵监测到master宕机，会自动将slave切换成master，然后通过发布订阅模式通知其他的从服务器，修改配置文件，让它们切换主机。<br>然而一个哨兵进程对Redis服务器进行监控，可能会出现问题，为此，我们可以使用多个哨兵进行监控。各个哨兵之间还会进行监控，这样就形成了多哨兵模式。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/26758626/1650289429010-e306c700-439f-404f-9be2-c6229d6ede0d.png#clientId=ue836c7aa-ce6f-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u89d7d337&margin=%5Bobject%20Object%5D&originHeight=560&originWidth=1051&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u498ec645-7144-4d33-916c-5cb850ba760&title="></p><p>假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行failover过程，仅仅是哨兵1主观的认为主服务器不可用，这个现象成为<strong>主观下线</strong>。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover[故障转移]操作。<br>切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为<strong>客观下线。</strong></p><p>我们目前的状态是 一主二从！<br><strong>配置步骤：</strong><br>1、配置哨兵配置文件 sentinel.conf</p><pre class="line-numbers language-none"><code class="language-none">sentinel monitor 哨兵名称 local post 1(表示有几个哨兵通过就让它称为老大)sentinel monitor myredis 182.92.209.212 6379 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>2.启动哨兵<br><img src="https://cdn.nlark.com/yuque/0/2022/png/26758626/1650289522530-e51e399e-5f5c-4c75-b98e-a61b20c8ca9a.png#clientId=ue836c7aa-ce6f-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u69c24dbb&margin=%5Bobject%20Object%5D&originHeight=666&originWidth=1108&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ud0f67cce-04b5-4671-88e6-3321641cf4d&title="></p><p>如果Master 节点断开了，这个时候就会从从机中随机选择一个服务器！ （这里面有一个投票算法！）<br>如果主机此时回来了，<strong>只能归并到新的主机下，当做从机</strong>，这就是哨兵模式的规则！</p><p><strong>哨兵模式优缺点</strong><br><strong>优点：</strong><br>1、哨兵集群，基于主从复制模式，所有的主从配置优点，它全有<br>2、 主从可以切换，故障可以转移，系统的<strong>可用性</strong>就会更好<br>3、哨兵模式就是主从模式的升级，<strong>手动到自动</strong>，更加健壮！<br><strong>缺点：</strong><br>1、Redis <strong>不好在线扩容</strong>的，集群容量一旦到达上限，在线扩容就十分麻烦！<br>2、实现哨兵模式的<strong>配置其实是很麻烦</strong>的，里面有很多选择！</p><h1 id="13-缓存穿透和缓存雪崩"><a href="#13-缓存穿透和缓存雪崩" class="headerlink" title="13. 缓存穿透和缓存雪崩"></a>13. 缓存穿透和缓存雪崩</h1><p><strong>服务的高可用问题</strong></p><p>Redis缓存的使用，极大的提升了应用程序的性能和效率，特别是数据查询方面。但同时，它也带来了一些问题。其中，最要害的问题，就是数据的一致性问题，从严格意义上讲，这个问题无解。如果对数据的一致性要求很高，那么就不能使用缓存。</p><p>另外的一些典型问题就是，缓存穿透、缓存雪崩和缓存击穿。目前，业界也都有比较流行的解决方案。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/26758626/1650289796937-5d2e880b-a99e-40b3-8c45-cad92a2829d0.png#clientId=ue836c7aa-ce6f-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u5d7c0a33&margin=%5Bobject%20Object%5D&originHeight=473&originWidth=1033&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ua4258262-59a4-43c7-8ac8-1253a25397b&title="></p><h2 id="缓存穿透（查不到数据）"><a href="#缓存穿透（查不到数据）" class="headerlink" title="缓存穿透（查不到数据）"></a>缓存穿透（查不到数据）</h2><p>缓存穿透的概念很简单，用户想要查询一个数据，发现redis内存数据库没有，也就是缓存没有命中，于是向持久层数据库查询。发现也没有，于是本次查询失败。当用户很多的时候，缓存都没有命中（秒杀！），于是都去请求了持久层数据库。这会给持久层数据库造成很大的压力，这时候就相当于出现了缓存穿透。</p><p>解决方案 ：布隆过滤器 和 缓存空对象<br>布隆过滤器是一种数据结构，对所有可能查询的参数<strong>以hash形式</strong>存储，在<strong>控制层先进行校验</strong>，不符合则丢弃，从而避免了对底层存储系统的查询压力。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/26758626/1650289943140-43e5375b-c1b0-46f0-9f06-5fdc8851c6cc.png#clientId=ue836c7aa-ce6f-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u5ae3c53e&margin=%5Bobject%20Object%5D&originHeight=653&originWidth=655&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u2cac1ec1-f8f9-40c0-9551-31bf378f6cf&title="></p><p>缓存空对象<br>当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间，之后再访问这个数据将会从缓存中获取，保护了后端数据源。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/26758626/1650290256789-afaa0834-5eea-429d-8f9e-0cba2e4ccbfd.png#clientId=ue836c7aa-ce6f-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u5faf905a&margin=%5Bobject%20Object%5D&originHeight=657&originWidth=578&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uf53ff829-2c96-4593-adcc-49fabfe5f9d&title="><br>但是这种方法会存在两个问题：</p><ul><li>1、如果空值能够被缓存起来，这就意味着缓存需要更多的空间存储更多的键，因为这当中可能会有很多的空值的键；</li><li>2、即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段<strong>时间窗口的不一致</strong>，这对于需要<strong>保持一致性</strong>的业务会有影响。</li></ul><h2 id="缓存击穿（量太大，缓存过期）"><a href="#缓存击穿（量太大，缓存过期）" class="headerlink" title="缓存击穿（量太大，缓存过期）"></a>缓存击穿（量太大，缓存过期）</h2><p>这里需要注意和缓存击穿的区别，缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，<strong>持续的大并发就穿破缓存</strong>，直接请求数据库，就像在一个屏障上凿开了一个洞。<br>当某个key在过期的瞬间，有大量的请求并发访问，<strong>这类数据一般是热点数据</strong>，由于缓存过期，会同时访问数据库来查询最新数据，并且回写缓存，会导使数据库瞬间压力过大。</p><p>解决方案： </p><ul><li>设置热点数据不过期<ul><li>从缓存层面来看，没有设置过期时间，所以不会出现热点 key 过期后产生的问题。</li></ul></li><li>加互斥锁<ul><li>使用分布式锁，保证对于每个key同时只有一个线程去查询后端服务，其他线程没有获得分布式锁的权限，因此只需要等待即可。这种方式将高并发的压力转移到了分布式锁，因此对分布式锁的考验很大。</li></ul></li></ul><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>缓存雪崩，是指在某一个时间段，<strong>缓存集中过期失效</strong>。Redis 宕机！<br>产生雪崩的原因之一，比如在写本文的时候，马上就要到双十二零点，很快就会迎来一波抢购，这波商品时间比较集中的放入了缓存，假设缓存一个小时。那么到了凌晨一点钟的时候，这批商品的缓存就都过期了。而对这批商品的访问查询，都落到了数据库上，对于数据库而言，<strong>就会产生周期性的压力波</strong>峰。于是所有的请求都会达到存储层，<strong>存储层的调用量会暴增</strong>，造成存储层也会挂掉的情况。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26758626/1650290628209-57409a28-b0f4-48ae-b19c-410998731809.png#clientId=ue836c7aa-ce6f-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u8677da01&margin=%5Bobject%20Object%5D&originHeight=640&originWidth=1109&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uaf5e9a9e-66dd-46af-8586-8d8a3f6c92c&title="></p><p>其实集中过期，倒不是非常致命，比较致命的缓存雪崩，是<strong>缓存服务器某个节点宕机或断网</strong>。因为自然形成的缓存雪崩，一定是在某个时间段集中创建缓存，这个时候，数据库也是可以顶住压力的。无非就是对数据库产生周期性的压力而已。而缓存服务节点的宕机，对数据库服务器造成的压力是不可预知的，很有可能瞬间就把数据库压垮。</p><p>解决方案：</p><ul><li>redis高可用</li></ul><p>这个思想的含义是，既然redis有可能挂掉，那我多增设几台redis，这样一台挂掉之后其他的还可以继续工作，其实就是搭建的集群。（异地多活！）</p><ul><li>限流降级（在SpringCloud讲解过！）</li></ul><p>这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。</p><ul><li>数据预热</li></ul><p>数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让<br>缓存失效的时间点尽量均匀。<br><a href="https://blog.51cto.com/zhangzhixi/3175577"></a></p><p><a href="https://blog.51cto.com/zhangzhixi/3175577"></a></p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql基础知识</title>
      <link href="/2022/04/13/Mysql%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2022/04/13/Mysql%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><ul><li><p><strong>mysql关键字不区分大小写</strong></p></li><li><p>创建数据库     </p><pre class="line-numbers language-none"><code class="language-none">create database [if not exists] westos;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>删除数据库</p><pre class="line-numbers language-none"><code class="language-none">drop database [if exists] westos;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>使用数据库</p><pre class="line-numbers language-none"><code class="language-none">use &#96;school&#96;-- 如果你的表名或者字段名是一个特殊字符（关键字），就需要带&#96;&#96;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><a name="bAxBQ"></a></p></li></ul><h2 id="数据库的列类型"><a href="#数据库的列类型" class="headerlink" title="数据库的列类型"></a>数据库的列类型</h2><p><a name="ZvL3k"></a></p><h4 id="1-数值"><a href="#1-数值" class="headerlink" title="1.数值"></a>1.数值</h4><pre><code>        - **整数**           1. tinyint  1个字节           1. smallint 2个字节           1. mediumint 3个字节           1. **int 4个字节**           1. bigint 8个字节        - 小数           1. float 4个字节           1. double 8个字节           1. decimal 字符串形式的浮点数</code></pre><p><a name="p7DiI"></a></p><h4 id="2-字符串"><a href="#2-字符串" class="headerlink" title="2.字符串"></a>2.字符串</h4><pre><code>        1. char 字符串固定大小的0-255        1. **varchar 可变字符串 0-65535常用的 String**        1. tinytext 微型文本 2^8-1        1. text 文本串 2^16-1</code></pre><p><a name="rCRjW"></a></p><h4 id="3-时间日期"><a href="#3-时间日期" class="headerlink" title="3.时间日期"></a>3.时间日期</h4><pre><code>        1. date YYYY-MM-DD 日期        1. time HH:mm：ss 时间格式        1. **datetime YYYY-MM-DD HH:mm：ss 最常用**        1. timestamp 时间戳 1970 1.1 到现在的毫秒数        1. year 年份表示</code></pre><p><a name="Jb3Dd"></a></p><h4 id="4-null"><a href="#4-null" class="headerlink" title="4.null"></a>4.null</h4><pre><code>        1. 没有值，未知         1. ==不要使用NULL进行运算</code></pre><p><a name="SVqqK"></a></p><h2 id="数据库的字段属性（重点）"><a href="#数据库的字段属性（重点）" class="headerlink" title="数据库的字段属性（重点）"></a>数据库的字段属性（重点）</h2><pre><code>     - unsigned ： 该列不能声明为负数     - zerofill：零填充      - 自增： 自动在上一条记录的基础上+1（默认）通常用来设计唯一的主键~index，必须是整数类型。     - 非空 ：Not null     - default ： 设置默认的值</code></pre><pre class="line-numbers language-none"><code class="language-none">&#x2F;* 每一个表，都必须存在以下五个字段！未来做项目用的，表示一个记录存在意义！id主键&#96;version&#96;乐观锁is_delete伪删除gmt_create创建时间gmt_update修改时间*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a name="z1lSm"></a></p><h2 id="创建数据库表"><a href="#创建数据库表" class="headerlink" title="创建数据库表"></a>创建数据库表</h2><pre class="line-numbers language-none"><code class="language-none">CREATE TABLE IF NOT EXISTS &#96;student&#96; (&#96;id&#96; INT(4) NOT NULL AUTO_INCREMENT COMMENT &#39;学号&#39;,&#96;name&#96; VARCHAR(30) NOT NULL DEFAULT &#39;匿名&#39; COMMENT &#39;姓名&#39;,&#96;pwd&#96; VARCHAR(20) NOT NULL DEFAULT &#39;123456&#39; COMMENT &#39;密码&#39;,&#96;sex&#96; VARCHAR(2) NOT NULL DEFAULT &#39;女&#39; COMMENT &#39;性别&#39;,&#96;birthday&#96; DATETIME DEFAULT NULL COMMENT &#39;出生日期&#39;,&#96;address&#96; VARCHAR(100) DEFAULT NULL COMMENT &#39;家庭住址&#39;,&#96;email&#96; VARCHAR(50) DEFAULT NULL COMMENT &#39;邮箱&#39;,PRIMARY KEY(&#96;id&#96;))ENGINE&#x3D;INNODB DEFAULT CHARSET&#x3D;utf8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a name="MwNAO"></a></p><h4 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h4><pre class="line-numbers language-none"><code class="language-none">CREATE TABLE [IF NOT EXISTS] &#96;表名&#96;(&#96;字段名&#96; 列属性 [属性] [索引] [注释]，    &#96;字段名&#96; 列属性 [属性] [索引] [注释]，    ......    &#96;字段名&#96; 列属性 [属性] [索引] [注释])[表类型][字符集设置][注释]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a name="Bk7eN"></a></p><h2 id="关于数据库引擎"><a href="#关于数据库引擎" class="headerlink" title="关于数据库引擎"></a>关于数据库引擎</h2><ul><li>Innodb：默认使用</li><li>MYISAM ：早些年使用</li></ul><p>区别：</p><table><thead><tr><th><br /></th><th>MYISAM</th><th>INNODB</th></tr></thead><tbody><tr><td>事务支持</td><td>不支持</td><td>支持</td></tr><tr><td>数据行锁定</td><td>不支持</td><td>支持</td></tr><tr><td>外键约束</td><td>不支持</td><td>支持</td></tr><tr><td>全文索引</td><td>支持</td><td>不支持</td></tr><tr><td>表空间的大小</td><td>较少</td><td>较大，约为MYISAM的2倍</td></tr></tbody></table><p>常规使用操作：<br />MYISAM: 节约空间，速度较快<br />Innodb：安全性高，事物的处理，多表多用户操作</p><p><a name="emxyx"></a></p><h2 id="修改删除表"><a href="#修改删除表" class="headerlink" title="修改删除表"></a>修改删除表</h2><p><a name="TKXo0"></a></p><h4 id="修改："><a href="#修改：" class="headerlink" title="修改："></a>修改：</h4><pre class="line-numbers language-none"><code class="language-none">-- 修改表名ALTER TABLE 旧表名 RENAME AS 新表名ALTER TABLE student RENAME AS student1-- 增加表的字段 ALTER TABLE 表名 ADD 字段名 字段的列属性ALTER TABLE student1 ADD age INT(3)-- 修改表的字段 （重命名，修改约束！）-- ALTER TABLE 表名 MODIFY 字段名 列属性[]ALTER TABLE student1 MODIFY age VARCHAR(3)   -- 修改约束-- ALTER TABLE 表名 MODIFY 旧字段名 新字段名 列属性[]ALTER TABLE student1 CHANGE age Age INT(3)   -- 字段重命名-- 删除表的字段ALTER TABLE 表名 DROP 字段名ALTER TABLE student1 DROP Age<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a name="WoGI6"></a></p><h4 id="删除："><a href="#删除：" class="headerlink" title="删除："></a>删除：</h4><pre class="line-numbers language-none"><code class="language-none">-- 删除表（如果表存在再删除）DROP TABLE IF EXISTS teacher<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><a name="NvsTd"></a></p><h2 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h2><pre class="line-numbers language-none"><code class="language-none">CREATE TABLE IF NOT EXISTS &#96;grade&#96; (&#96;gradeid&#96; INT(10) NOT NULL AUTO_INCREMENT COMMENT &#39;年级id&#39;,&#96;gradename&#96; VARCHAR(50) NOT NULL COMMENT &#39;年级名称&#39;,PRIMARY KEY(&#96;gradeid&#96;))ENGINE&#x3D;INNODB DEFAULT CHARSET&#x3D;utf8CREATE TABLE IF NOT EXISTS &#96;student&#96; (&#96;id&#96; INT(4) NOT NULL AUTO_INCREMENT COMMENT &#39;学号&#39;,&#96;name&#96; VARCHAR(30) NOT NULL DEFAULT &#39;匿名&#39; COMMENT &#39;姓名&#39;,&#96;pwd&#96; VARCHAR(20) NOT NULL DEFAULT &#39;123456&#39; COMMENT &#39;密码&#39;,&#96;sex&#96; VARCHAR(2) NOT NULL DEFAULT &#39;女&#39; COMMENT &#39;性别&#39;,&#96;birthday&#96; DATETIME DEFAULT NULL COMMENT &#39;出生日期&#39;,&#96;gradeid&#96; INT(10) NOT NULL COMMENT &#39;学生的年级&#39;,&#96;address&#96; VARCHAR(100) DEFAULT NULL COMMENT &#39;家庭住址&#39;,&#96;email&#96; VARCHAR(50) DEFAULT NULL COMMENT &#39;邮箱&#39;,PRIMARY KEY(&#96;id&#96;))ENGINE&#x3D;INNODB DEFAULT CHARSET&#x3D;utf8ALTER TABLE &#96;student&#96;ADD CONSTRAINT &#96;FK_gradeid&#96; FOREIGN KEY (&#96;gradeid&#96;) REFERENCES &#96;grade&#96; (&#96;gradeid&#96;)-- ALTER TABLE 表名 ADD CONSTRAINT 约束名 FOREIGN KEY（作为外键的列）REFERENCES 哪个表（哪个字段）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上的操作都是物理外键，数据库级别的外键，不建议使用！（避免数据库过多造成困扰）<br /><strong>最佳实践</strong></p><ul><li>数据库就是单纯的表，只用来存数据，只有行（数据）和列（字段）</li><li>我们想使用多张表的数据，想使用外键（程序去实现）<br><a name="VR11g"></a></li></ul><h2 id="sql操作"><a href="#sql操作" class="headerlink" title="sql操作"></a>sql操作</h2><p><a name="BZw8Q"></a></p><h4 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h4><p>语法：<code>insert into 表名([字段1,字段2,字段3]) values(&#39;值1&#39;),(&#39;值2&#39;),(&#39;值3&#39;,...)</code></p><pre class="line-numbers language-none"><code class="language-none">-- 插入语句（添加）-- insert into 表名([字段1,字段2,字段3]) values(&#39;值1&#39;),(&#39;值2&#39;),(&#39;值3&#39;,...)INSERT INTO &#96;grade&#96;(&#96;gradename&#96;) VALUES (&#39;大四&#39;)-- 由于主键自增我们可以省略 （如果不写表的字段，他就会一一匹配）INSERT INTO &#96;grade&#96; VALUES (&#39;大三&#39;)-- 一般写插入语句，我们一定要数据和字段一一对应！-- 插入多个字段INSERT INTO &#96;grade&#96;(&#96;gradename&#96;) VALUES (&#39;大三&#39;),(&#39;大二&#39;),(&#39;大一&#39;)INSERT INTO &#96;student&#96;(&#96;name&#96;) VALUES (&#39;张三&#39;)INSERT INTO &#96;student&#96;(&#96;name&#96;,&#96;pwd&#96;,&#96;sex&#96;) VALUES (&#39;张三&#39;,&#39;aaaaaa&#39;,&#39;男&#39;)INSERT INTO &#96;student&#96;(&#96;name&#96;,&#96;pwd&#96;,&#96;sex&#96;) VALUES (&#39;李四&#39;,&#39;aaaaaa&#39;,&#39;男&#39;),(&#39;王五&#39;,&#39;aaaaaa&#39;,&#39;男&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：</p><pre><code>  1. 字段和字段之间使用英文逗号隔开  1. 字段是可以省略的，但是后面的值必须要一一对应，不能少  1. 可以同时插入多条数据，VALUES后面的值，需要使用，隔开即可VALUSE (),(),...</code></pre><p><a name="LYeek"></a></p><h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><p>语法：UPDATE 表名 SET colnum_name&#x3D;value，[colnum_name&#x3D;value,…] WHERE [条件]</p><p><a name="gFZum"></a></p><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>语法：delete from 表名 [where 条件]&#96;<br />Truncate命令：完全清空一个数据库表，表的结构和索引约束不会变！<br><a name="nHAac"></a></p><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><p>语法：SELECT 字段,… FROM 表</p><p><strong>distinct</strong><br />作用：去除SELECT查询出来的结果中重复的数据，重复的数据只显示一条</p><p><a name="DZMxb"></a></p><h6 id="联表查询"><a href="#联表查询" class="headerlink" title="联表查询"></a>联表查询</h6><p>Join<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/26758626/1648484644146-dff18579-65cd-4869-b455-affe56c8fdf8.png" alt="image.png"><br />   </p><table><thead><tr><th>操作符名称</th><th>描述</th></tr></thead><tbody><tr><td>INNER JOIN</td><td>如果表中至少有一个匹配，则返回行</td></tr><tr><td>LEFT JOIN</td><td>即使右表中没有匹配，也从左表中返回所有的行</td></tr><tr><td>RIGHT JOIN</td><td>即使左表中没有匹配，也从右表中返回所有的行</td></tr></tbody></table><p><strong>自连接</strong><br />自己的表和自己的表连接，核心：<strong>一张表拆为两张一样的表即可</strong><br><a name="gJmwK"></a></p><h4 id="分页和排序"><a href="#分页和排序" class="headerlink" title="分页和排序"></a>分页和排序</h4><p><a name="L8XZn"></a></p><h6 id="排序："><a href="#排序：" class="headerlink" title="排序："></a>排序：</h6><pre><code>     - 关键字：order by     - 升序 : asc     - 降序 ：desc</code></pre><p><a name="hqWZD"></a></p><h6 id="分页："><a href="#分页：" class="headerlink" title="分页："></a>分页：</h6><pre><code>     - 语法：limit 起始页 页面的大小</code></pre><p><a name="Dj0Iv"></a></p><h4 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h4><table><thead><tr><th>函数名称</th><th>描述</th></tr></thead><tbody><tr><td>COUNT()</td><td>计数</td></tr><tr><td>SUM()</td><td>求和</td></tr><tr><td>AVG()</td><td>平均值</td></tr><tr><td>MAX()</td><td>最大值</td></tr><tr><td>MIN()</td><td>最小值</td></tr></tbody></table><p>注意：</p><ul><li>从含义上讲，count(1) 与 count(*) 都表示对全部数据行的查询。<ul><li>count(字段) 会统计该字段在表中出现的次数，忽略字段为null 的情况。即不统计字段为null 的记录。</li><li>count(*) 包括了所有的列，相当于行数，在统计结果的时候，包含字段为null 的记录；</li><li>count(1) 用1代表代码行，在统计结果的时候，包含字段为null 的记录 。<br><a name="FJmoq"></a></li></ul></li></ul><h4 id="分组和过滤"><a href="#分组和过滤" class="headerlink" title="分组和过滤"></a>分组和过滤</h4><pre class="line-numbers language-none"><code class="language-none">-- 查询不同课程的平均分,最高分,最低分-- 前提:根据不同的课程进行分组SELECT subjectname,AVG(studentresult) AS 平均分,MAX(StudentResult) AS 最高分,MIN(StudentResult) AS 最低分FROM result AS rINNER JOIN &#96;subject&#96; AS sON r.subjectno &#x3D; s.subjectnoGROUP BY r.subjectno --通过什么字段来分组HAVING 平均分&gt;80;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>分组之后，只能用having过滤</strong></p><p><a name="XkaND"></a></p><h2 id="数据库级别的MD5"><a href="#数据库级别的MD5" class="headerlink" title="数据库级别的MD5"></a>数据库级别的MD5</h2><ul><li>主要增强算法复杂度和不可逆性</li><li>MD5<strong>不可逆</strong>，具体的值的MD5是一样的</li><li>MD5破解网站的原理，背后有一个字典，MD5加密后的值，加密的前值<br><a name="ZVnEq"></a></li></ul><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>定义：将一组sql放在一个批次中去执行<br><a name="mfaZW"></a></p><h4 id="事务-ACID原则"><a href="#事务-ACID原则" class="headerlink" title="事务 ACID原则"></a>事务 ACID原则</h4><pre><code>        - 原子性（Atomicity）</code></pre><p><strong>不可分割，要么都成功，要么都失败</strong></p><pre><code>        - 一致性（Consistency）</code></pre><p><strong>事务前后的数据的完整性保持一致</strong></p><pre><code>        - 隔离性（Isolation）</code></pre><p><strong>事务的隔离型性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离</strong></p><pre><code>        - 持久性（Durabilty）</code></pre><p><strong>事务一旦提交则不可逆，被持久化到数据库中</strong><br><a name="OddDZ"></a></p><h4 id="引发的问题"><a href="#引发的问题" class="headerlink" title="引发的问题"></a>引发的问题</h4><p><a name="Z5w5Z"></a></p><h6 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h6><p>一个事务读取了另一个事物未提交的数据<br><a name="tKYK4"></a></p><h6 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h6><p>在一个事务内读取表中某一行的数据，多次读取的结果不同<br><a name="GbnC2"></a></p><h6 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h6><p>在一个事务内读取到了另一个事务插入的数据，导致前后读取的数据总量不一致。  <br />MySQL是默认开启事务提交的</p><pre class="line-numbers language-none"><code class="language-none">-- 事务-- mysql是默认开启事务自动提交的SET autocommit &#x3D; 0 -- 关闭SET autocommit &#x3D; 1 -- 开启（默认的）-- 手动处理事务SET autocommit &#x3D; 0 -- 关闭自动提交-- 事务开启START TRANSACTION -- 标记一个事务的开始，从这个之后的sql都在同一个事务内-- 提交 ： 持久化 （成功！）COMMIT-- 回滚： 回到原来的样子 （失败！）ROLLBACK-- 事务结束SET autocommit &#x3D; 1 -- 开启自动提交SAVEPOINT 保存点名 -- 设置一个事务的保存点ROLLBACK TO SAVEPOINT 保存点名 -- 回滚到保存点RELEASE SAVEPOINT 保存点名 -- 撤销保存点<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a name="SG1wt"></a></p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>本质：是一种数据结构，帮助高效获取数据。<br><a name="y2z0u"></a></p><h4 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h4><ul><li>主键索引（primary key）</li></ul><p>唯一标识，主键不可重复，只能有一个列作为主键</p><ul><li>唯一索引（Unique key）</li></ul><p>可重复，避免重复的列出现，多个列都可以标识为唯一索引</p><ul><li>常规索引（key&#x2F;index）</li></ul><p>默认，index&#x2F;key 来设置</p><ul><li>全文索引（FullText）</li></ul><p>在特定的数据库引擎下才有，如：MyISAM<br />快速定位数据<br><a name="xUGbf"></a></p><h4 id="索隐原则："><a href="#索隐原则：" class="headerlink" title="索隐原则："></a>索隐原则：</h4><ul><li>不是越多越好</li><li>不要对进程变动数据加索引</li><li>小数据量的表不需要加索引</li><li>索引一般加在常用来查询的字段上<br><a name="IAacW"></a></li></ul><h4 id="数据结构：B-TREE（Innodb的默认数据结构）"><a href="#数据结构：B-TREE（Innodb的默认数据结构）" class="headerlink" title="数据结构：B TREE（Innodb的默认数据结构）"></a>数据结构：B TREE（Innodb的默认数据结构）</h4><p><a name="IQDeT"></a></p><h2 id="数据库三大范式"><a href="#数据库三大范式" class="headerlink" title="数据库三大范式"></a>数据库三大范式</h2><p><strong>为什么需要数据规范化？</strong></p><ul><li>信息重复</li><li>更新异常</li><li>插入异常<ul><li>无法正常显示信息</li></ul></li><li>删除异常<ul><li>丢失有效的信息</li></ul></li></ul><p><strong>三大范式</strong><br><a name="ittiW"></a></p><h4 id="第一范式-1st-NF"><a href="#第一范式-1st-NF" class="headerlink" title="第一范式 (1st NF)"></a>第一范式 (1st NF)</h4><p>要求数据库表的每一列都是不可分割的原子数据项。<br><a name="eyS6M"></a></p><h4 id="第二范式-2nd-NF"><a href="#第二范式-2nd-NF" class="headerlink" title="第二范式(2nd NF)"></a>第二范式(2nd NF)</h4><p>满足第二范式（2NF）必须先满足第一范式（1NF）。<br />第二范式要求每个表只描述一件事情<br /><strong>在第一范式的基础上，非主属性必须完全依赖于候选码（消除非主属性对于主码的部分函数依赖）</strong><br />确保每一列都和主键相关，而不能只与主键的某一部分相关<br><a name="gm1UK"></a></p><h4 id="第三范式-3rd-NF"><a href="#第三范式-3rd-NF" class="headerlink" title="第三范式(3rd NF)"></a>第三范式(3rd NF)</h4><p>满足第三范式（3NF）必须先满足第二范式（2NF）。<br /><strong>第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。</strong><br /><strong>任何非主属性不依赖于其他非主属性</strong><br /><strong>消除了传递依赖</strong></p><p>三个范式是规范了数据库的设计<br /><strong>规范性 和 性能的问题</strong><br />关联查询的表不得超过三张表</p><ul><li>考虑商业化的需求和目标，（成本，用户体验！）数据库的性能更加重要</li><li>在规范性能的问题的时候，需要适当的考虑一下 规范性！</li><li>故意给某些表增加一些冗余的字段。（从多表查询中变为单表查询）</li><li>故意增加一些计算列（从大数据量降低为小数据量的查询：索引）</li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM</title>
      <link href="/2022/04/13/JVM/"/>
      <url>/2022/04/13/JVM/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><ul><li>请你谈谈对JVM的理解? java8虚拟机和之前的变化更新</li><li>什么是OOM(内存溢出)? 什么是栈溢出(stackOverFlowError)? 怎么分析?</li><li>JVM常用的调优参数有哪些?</li><li>内存快照如何抓取? 怎么分析Domp文件 ? 知道吗?</li><li>谈谈JVM中,类加载器你的认识?</li></ul><h2 id="1-JVM的位置"><a href="#1-JVM的位置" class="headerlink" title="1.JVM的位置"></a>1.JVM的位置</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26758626/1648544772214-88c91aeb-5084-40ed-9c39-0c263f359e4a.png#clientId=ua2864186-cdc8-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u0bda4197&originHeight=526&originWidth=524&originalType=url&ratio=1&rotation=0&showTitle=false&size=119986&status=done&style=none&taskId=ue48ccd1e-4dab-4c86-af41-84396fa35fe&title=" alt="image.png"></p><h2 id="2-jvm的体系"><a href="#2-jvm的体系" class="headerlink" title="2.jvm的体系"></a>2.jvm的体系</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26758626/1648544892759-f947e880-ceb1-42db-b98e-8d5295b63562.png#clientId=ua2864186-cdc8-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u9136ed99&originHeight=586&originWidth=863&originalType=url&ratio=1&rotation=0&showTitle=false&size=141205&status=done&style=none&taskId=u395bb536-6df4-4fe2-b7f3-161c9f30130&title=" alt="image.png"><br /><img src="https://cdn.nlark.com/yuque/0/2022/png/26758626/1648545189519-c0d39c94-e78b-4ff1-99c8-023090c5a5b2.png#clientId=ua2864186-cdc8-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u4f6323d3&originHeight=525&originWidth=738&originalType=url&ratio=1&rotation=0&showTitle=false&size=117675&status=done&style=none&taskId=uc2c6e7e2-5ec3-427d-b07d-8180845e934&title=" alt="image.png"></p><h2 id="3-类加载器"><a href="#3-类加载器" class="headerlink" title="3.类加载器"></a>3.类加载器</h2><pre><code> 作用：加载 class文件</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26758626/1648545610429-11508ee3-4ac1-4533-8b86-4bb382797f39.png#clientId=ua2864186-cdc8-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uaabadb7f&originHeight=438&originWidth=741&originalType=url&ratio=1&rotation=0&showTitle=false&size=66883&status=done&style=none&taskId=u09a651ba-7a78-4883-9734-b2dbb1fcb67&title=" alt="image.png"><br />种类：</p><ul><li>虚拟机自带的加载器</li><li>启动类（根）加载器</li><li>扩展类加载器</li><li>应用程序加载器</li></ul><h2 id="4-双亲委派机制"><a href="#4-双亲委派机制" class="headerlink" title="4.双亲委派机制"></a>4.双亲委派机制</h2><p>app—&gt;扩展类(ext) —-&gt; (启动类)根加载器(rt)<br />当一个类收到了类加载请求，他首先不会尝试自己去加载这个类，而是把这个请求委派给父类去完成，每一个层次类加载器都是如此， 因此所有的加载请求都应该传送到启动类加载其中<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/26758626/1648547288200-e817c805-1153-4ccc-8b71-4fa78816f63d.png#clientId=ua2864186-cdc8-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u02054e79&originHeight=1240&originWidth=1312&originalType=url&ratio=1&rotation=0&showTitle=false&size=473279&status=done&style=none&taskId=u51bcbf5d-9d34-4b25-bb23-55565a4351b&title=" alt="image.png"><br /><strong>过程：</strong>当一个类加载请求开始时，首先从APPClassLoader进入，先判断是否已经加载过，若加载过则不再加载，若没加载过，则交给自己的上层扩展类加载器，然后相同步骤，若没加载过，再交给启动类加载器，若启动类加载器也没加载过，此时已经没有再上一层的加载器了，于是判断自己是否可以加载，如果不能加载，则下沉到下一层的扩展类加载器，以此类推，直到应用程序类加载器，如果最后都不能加载，则报出ClassNotFoundException错误</p><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ul><li>避免重复加载类</li><li>沙箱安全机制</li></ul><h2 id="5-沙箱安全机制"><a href="#5-沙箱安全机制" class="headerlink" title="5.沙箱安全机制"></a>5.沙箱安全机制</h2><p>保证核心<a href="https://so.csdn.net/so/search?q=API&spm=1001.2101.3001.7020">API</a>源代码的保护，引导类加载器只加载核心API，不加载自定义的与核心API同名或同包名的API。</p><h2 id="6-Native"><a href="#6-Native" class="headerlink" title="6.Native"></a>6.Native</h2><p>Native 关键字 调用 本地方法栈—-&gt; JNI (java Native Interface本地方法接口) 调用外部语言程序<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/26758626/1648719749093-fc63d693-66f6-4ddd-a0b6-c2d93d12db46.png#clientId=uc724b46b-187a-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u27af7b57&originHeight=170&originWidth=692&originalType=url&ratio=1&rotation=0&showTitle=false&size=163877&status=done&style=none&taskId=uc6b8be60-239f-48d9-a808-7bc33c406c2&title=" alt="image.png"></p><h2 id="7-程序计数器"><a href="#7-程序计数器" class="headerlink" title="7.程序计数器"></a>7.程序计数器</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26758626/1648720191895-f42faef2-9093-4945-a6ab-01bd7fbc603b.png#clientId=uc724b46b-187a-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u8db8404b&originHeight=128&originWidth=838&originalType=url&ratio=1&rotation=0&showTitle=false&size=101469&status=done&style=none&taskId=u58c5c243-f703-4e50-852d-7ee764e785a&title=" alt="image.png"></p><h2 id="8-方法区"><a href="#8-方法区" class="headerlink" title="8.方法区"></a>8.方法区</h2><p>方法区是被所有线程共享的,所有字段和方法字节码,以及一些特殊方法,如构造函数,接口代码也在此定义,简单说,所有定义的方法的信息都保存在该区域,<strong>此区域属于共享区间</strong>;<br />静态变量(static),常量(final),类信息(构造方法,接口定义),运行时的常量池存在方法区中,但是实例变量存在堆内存中,和方法区无关.<br />static ,final, Class , 常量池</p><h2 id="9-栈"><a href="#9-栈" class="headerlink" title="9.栈"></a>9.栈</h2><p>栈:栈<a href="https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98&spm=1001.2101.3001.7020">内存</a>,主管程序的运行,生命周期和线程同步;<br />线程结束,栈内存也就释放了,对于栈来说,不存在垃圾回收问题<br />一旦线程结束,栈就Over<br /><strong>主要存储</strong>：8大基本类型+ 对象引用+实例的方法</p><h2 id="10-堆"><a href="#10-堆" class="headerlink" title="10.堆"></a>10.堆</h2><p>一个JVM只有一个堆内存，堆内存的大小是可以调节的<br />堆内存中还要细分为三个区域:</p><ul><li>新生区 (伊甸园区) Young&#x2F;New ,eden space</li><li>养老区 old</li><li>永久区 Permanent jdk8之后叫做 “元空间”</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26758626/1648733899530-02206d74-10b0-41e6-b782-a205317234a9.png#clientId=uc724b46b-187a-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ud0377ec7&originHeight=574&originWidth=811&originalType=url&ratio=1&rotation=0&showTitle=false&size=137333&status=done&style=none&taskId=uef230b42-b2c5-4a52-bbf8-cd5cb9d236a&title=" alt="image.png"></p><h3 id="新生区（满了-轻GC）"><a href="#新生区（满了-轻GC）" class="headerlink" title="新生区（满了 轻GC）"></a>新生区（满了 轻GC）</h3><ul><li><p>类 ： 诞生和成长的地方 ， 甚至死亡；</p></li><li><p>伊甸园， 所有的对象都是在伊甸园区new出来的</p></li><li><p>幸存区（0，1）</p></li><li><p>经研究99%的对象都是临时对象</p><h3 id="老年区（满了-重GC）"><a href="#老年区（满了-重GC）" class="headerlink" title="老年区（满了 重GC）"></a>老年区（满了 重GC）</h3><h3 id="永久区（元空间）"><a href="#永久区（元空间）" class="headerlink" title="永久区（元空间）"></a>永久区（元空间）</h3><p>这个区域常驻内存的. 用来存放jdk自身携带的Class对象.Interface元数据,存储的是java运行时的一些环境或类信息,这个区域不存在垃圾回收!关闭vm虚拟就会释放这个区域的内存~.</p></li><li><p>jdk1.6之前 :永久代,常量池是在方法区;</p></li><li><p>jdk1.7 :永久代,但是慢慢退化了, 去永久代,常量池在堆中;</p></li><li><p>jdk1.8之后:无永久代, 常量池在元空间;</p></li><li><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26758626/1648735076894-6d8dd9c3-d949-4563-acad-7532a5ccc557.png#clientId=uc724b46b-187a-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u76447e61&originHeight=186&originWidth=670&originalType=url&ratio=1&rotation=0&showTitle=false&size=43913&status=done&style=none&taskId=ubb4b290d-d691-4bf5-9b65-c324405fb4c&title=" alt="image.png"></p></li></ul><p>元空间逻辑上存在，物理上不存在</p><h2 id="11-GC-垃圾回收"><a href="#11-GC-垃圾回收" class="headerlink" title="11.GC 垃圾回收"></a>11.GC 垃圾回收</h2><p>GC:作用区域 堆+方法区<br />JVM在进行GC时，并不是对这三个区域统一回收。大部分时候，回收都是新生代~</p><ul><li>新生代</li><li>幸存区（from ， to）</li><li>老年区</li></ul><p>GC两种：轻GC（普通GC），重GC（全局GC）</p><h2 id="12-常用算法"><a href="#12-常用算法" class="headerlink" title="12.常用算法"></a>12.常用算法</h2><h3 id="1-复制算法"><a href="#1-复制算法" class="headerlink" title="1.复制算法"></a>1.复制算法</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26758626/1648800715617-4d2b2864-bc17-4c29-873e-7d7a176bba81.png#clientId=uef992677-9ebd-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u94fd49aa&originHeight=620&originWidth=773&originalType=url&ratio=1&rotation=0&showTitle=false&size=201085&status=done&style=none&taskId=ub9dc2040-a063-4557-b771-e971b908039&title=" alt="image.png"></p><ul><li><p>好处:没有内存的碎片</p></li><li><p>坏处:浪费了内存空间:多了一半空间永远是空 to.假设对象100%存活(极端情况)</p></li><li><p><strong>复制算法最佳使用场景</strong>:对象存活度较低的时候:新生区;</p><h3 id="2-标记清除法"><a href="#2-标记清除法" class="headerlink" title="2.标记清除法"></a>2.标记清除法</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26758626/1648800795077-d75a4b16-4501-4c95-b525-842c971743d0.png#clientId=uef992677-9ebd-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uc89d7bb4&originHeight=513&originWidth=775&originalType=url&ratio=1&rotation=0&showTitle=false&size=120928&status=done&style=none&taskId=u8bd7aacb-8633-4feb-ab4d-d603c5fca19&title=" alt="image.png"></p></li><li><p>优点:不需要额外的空间</p></li><li><p>缺点:两次扫描,严重浪费时间,会产生内存碎片</p><h3 id="3-标记整理法"><a href="#3-标记整理法" class="headerlink" title="3.标记整理法"></a>3.标记整理法</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26758626/1648801445534-4625394c-fec6-4e6c-b97d-2c5680584317.png#clientId=uef992677-9ebd-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u741eb630&originHeight=568&originWidth=531&originalType=url&ratio=1&rotation=0&showTitle=false&size=116947&status=done&style=none&taskId=u00658d2e-c9f3-4909-95b1-f855cae4a3a&title=" alt="image.png"></p><h3 id="4-算法比较"><a href="#4-算法比较" class="headerlink" title="4.算法比较"></a>4.算法比较</h3></li></ul><p><strong>效率</strong>:复制算法&gt;标记清除算法&gt;标记压缩算法(时间复杂度)<br /><strong>内存整齐度</strong>:复制算法&#x3D;标记压缩算法&gt;标记清除算法<br /><strong>内存利用率</strong>:标记压缩算法&#x3D;标记清除算法&gt;复制算法</p>]]></content>
      
      
      <categories>
          
          <category> Java虚拟机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/04/13/hello-world/"/>
      <url>/2022/04/13/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> First Blog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
